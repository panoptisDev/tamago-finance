{
  "language": "Solidity",
  "sources": {
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@chainlink/contracts/src/v0.6/VRFConsumerBase.sol\";\n\n/**\n * @title Factory for creating new luckbox contract.\n */\n\ncontract Factory is VRFConsumerBase, ReentrancyGuard, Ownable {\n  using SafeERC20 for IERC20;\n\n  struct Box {\n    string name;\n    string symbol;\n    address owner;\n    address contractAddress;\n    bool banned;\n    bool approved;\n  }\n\n  Box[] public boxes;\n  uint256 public totalBoxes;\n\n  // Nonce to be generated by Chainlink VRF\n  uint256 public randomNonce;\n  mapping(bytes32 => address) private requestIdToAddress;\n\n  // Fee section\n  address public devAddr;\n  uint256 public feePercent = 300; // 3%\n  uint256 public constant MAX_FEE = 1000; // 10%\n\n  uint256 public COOLDOWN = 3 seconds;\n  uint256 public timestamp;\n\n  // Chainlink constants on Polygon\n  address public constant VRF_COORDINATOR =\n    0x3d2341ADb2D31f1c5530cDC622016af293177AE0;\n  address public constant LINK_TOKEN =\n    0xb0897686c545045aFc77CF20eC7A532E3120E0F1;\n  bytes32 public constant KEY_HASH =\n    0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;\n  uint256 public constant FEE = 100000000000000; // 0.0001 LINK\n\n  event SetFee(uint256 _fee);\n  event SetDevAddr(address _devAddr);\n  event RequestedNonce(address user, uint256 timestamp);\n\n  constructor(address _devAddr)\n    public\n    VRFConsumerBase(VRF_COORDINATOR, LINK_TOKEN)\n  {\n    require(_devAddr != address(0), \"Address is zero\");\n    devAddr = _devAddr;\n  }\n\n  // request a new nonce from Chainlink VRF\n  function requestNonce() public nonReentrant {\n    require(\n      IERC20(LINK_TOKEN).balanceOf(address(this)) >= FEE,\n      \"Insufficient LINK to proceed VRF\"\n    );\n    require(\n      block.timestamp >= timestamp + COOLDOWN,\n      \"Still in cooldown period\"\n    );\n\n    bytes32 requestId = requestRandomness(KEY_HASH, FEE);\n    requestIdToAddress[requestId] = msg.sender;\n\n    emit RequestedNonce(msg.sender, block.timestamp);\n  }\n\n  function totalLink() public view returns (uint256) {\n    return IERC20(LINK_TOKEN).balanceOf(address(this));\n  }\n\n  function getBoxOwner(uint256 _id) public view returns (address) {\n    return boxes[_id].owner;\n  }\n\n  function getBoxContractAddress(uint256 _id) public view returns (address) {\n    return boxes[_id].contractAddress;\n  }\n\n  function getBoxName(uint256 _id) public view returns (string memory) {\n    return boxes[_id].name;\n  }\n\n  function getBoxSymbol(uint256 _id) public view returns (string memory) {\n    return boxes[_id].symbol;\n  }\n\n  function isBanned(uint256 _id) public view returns (bool) {\n    return boxes[_id].banned;\n  }\n\n  function isApproved(uint256 _id) public view returns (bool) {\n    return boxes[_id].approved;\n  }\n\n  // ADMIN FUNCTIONS\n  function setDevAddr(address _devAddr) public onlyOwner nonReentrant {\n    require(_devAddr != address(0), \"Address zero !\");\n    devAddr = _devAddr;\n\n    emit SetDevAddr(devAddr);\n  }\n\n  function setFee(uint256 _feePercent) public onlyOwner nonReentrant {\n    require(_feePercent <= MAX_FEE, \"Below MAX_FEE Please\");\n    feePercent = _feePercent;\n\n    emit SetFee(feePercent);\n  }\n\n  function setBan(uint256 _id, bool _isBan) public onlyOwner nonReentrant {\n    boxes[_id].banned = _isBan;\n  }\n\n  function setApprove(uint256 _id, bool _isApprove)\n    public\n    onlyOwner\n    nonReentrant\n  {\n    boxes[_id].approved = _isApprove;\n  }\n\n  function withdrawLink(uint256 _amount) public onlyOwner nonReentrant {\n    IERC20(LINK_TOKEN).safeTransfer(msg.sender, _amount);\n  }\n\n  // for maintenance purpose\n  function forceNonceUpdate(uint256 _nonce) public onlyOwner nonReentrant {\n    randomNonce = _nonce;\n  }\n\n  // PRIVATE FUNCTIONS\n\n  // callback from Chainlink VRF\n  function fulfillRandomness(bytes32 requestId, uint256 _randomness)\n    internal\n    override\n  {\n    randomNonce = _randomness;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./vendor/SafeMathChainlink.sol\";\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n\n  using SafeMathChainlink for uint256;\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\n    internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee)\n    internal returns (bytes32 requestId)\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash].add(1);\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface immutable internal LINK;\n  address immutable private vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) public {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathChainlink {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.6/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract VRFRequestIDBase {\n\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n    address _requester, uint256 _nonce)\n    internal pure returns (uint256)\n  {\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/mocks/MockP2P.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./MockERC721.sol\";\n\ncontract MockP2P is\n  ReentrancyGuard,\n  Ownable,\n  IERC721Receiver,\n  ERC1155Holder,\n  ERC721Holder\n{\n  uint256 public feeBps;\n  uint256 public price;\n  MockERC721 public nft;\n\n  event Swap(address indexed buyer, uint256 tokenId);\n  event SetPrice(uint256 price);\n\n  constructor(\n    uint256 _price,\n    string memory _name,\n    string memory _symbol\n  ) public {\n    price = _price;\n\n    nft = new MockERC721(_name, _symbol);\n\n    emit SetPrice(_price);\n  }\n\n  /// @dev Updates price. Only callable by owner.\n  function setPrice(uint256 _price) external onlyOwner {\n    price = _price;\n    emit SetPrice(_price);\n  }\n\n  /// @dev Withdraw trading fees. Only called by owner.\n  function withdraw(uint256 amount) external onlyOwner {\n    payable(msg.sender).transfer(amount == 0 ? address(this).balance : amount);\n  }\n\n  /// @dev Buy nft from the contract.\n  function buy() external payable nonReentrant {\n    require(msg.value == price, \"!not enough or more over\");\n    uint256 tokenId = nft.totalSupply();\n    nft.mint(msg.sender, tokenId);\n\n    emit Swap(msg.sender, tokenId);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC721Receiver.sol\";\n\n  /**\n   * @dev Implementation of the {IERC721Receiver} interface.\n   *\n   * Accepts all token transfers. \n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n   */\ncontract ERC721Holder is IERC721Receiver {\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/mocks/MockERC721.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MockERC721 is ERC721 {\n\n    constructor(string memory name, string memory symbol) public ERC721(name, symbol) {\n        // Use CryptoKitties as a base URI for this mock collection\n        _setBaseURI(\"https://api.cryptokitties.co/kitties/\");\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function setTokenURI(uint256 tokenId, string memory uri) public {\n        _setTokenURI(tokenId, uri);\n    }\n\n    function setBaseURI(string memory baseURI) public {\n        _setBaseURI(baseURI);\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId, bytes memory _data) public {\n        _safeMint(to, tokenId, _data);\n    }\n\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    constructor() internal {\n        _registerInterface(\n            ERC1155Receiver(address(0)).onERC1155Received.selector ^\n            ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "contracts/mocks/MockNFTDex.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ncontract MockNFTDex is\n  ReentrancyGuard,\n  Ownable,\n  IERC721Receiver,\n  ERC1155Holder,\n  ERC721Holder\n{\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  uint256 public feeBps;\n  mapping(address => mapping(address => EnumerableSet.UintSet))\n    private myTokenIdSet; // user address => nft address => id\n  mapping(address => EnumerableSet.AddressSet) private myNFTSet; // user address => nft adress\n\n  EnumerableSet.AddressSet private nftSet;\n  mapping(address => EnumerableSet.UintSet) private tokenIdSet;\n\n  mapping(address => mapping(uint256 => uint256)) public prices; // nft => tokenId => price\n  mapping(uint256 => mapping(address => address)) public listers; // tokenId => nft => lister\n\n  event List(\n    address indexed nft,\n    uint256 indexed id,\n    address indexed lister,\n    uint256 price\n  );\n  event Unlist(address indexed nft, uint256 indexed id, address indexed lister);\n  event Buy(\n    address nft,\n    uint256 indexed id,\n    address indexed seller,\n    address indexed buyer,\n    uint256 price,\n    uint256 fee\n  );\n  event SetFeeBps(uint256 feeBps);\n\n  constructor(uint256 _feeBps) public {\n    feeBps = _feeBps;\n\n    emit SetFeeBps(_feeBps);\n  }\n\n  /// @dev Updates fee. Only callable by owner.\n  function setFeeBps(uint256 _feeBps) external onlyOwner {\n    feeBps = _feeBps;\n    emit SetFeeBps(_feeBps);\n  }\n\n  /// @dev Lists the given summoner. This contract will take custody until bought / unlisted.\n  function list(\n    address nft,\n    uint256 tokenId,\n    uint256 price\n  ) external nonReentrant {\n    require(price > 0, \"bad price\");\n    require(prices[nft][tokenId] == 0, \"already listed\");\n    IERC721(nft).safeTransferFrom(msg.sender, address(this), tokenId);\n    prices[nft][tokenId] = price;\n    listers[tokenId][nft] = msg.sender;\n    nftSet.add(nft);\n    tokenIdSet[nft].add(tokenId);\n    myTokenIdSet[msg.sender][nft].add(tokenId);\n    myNFTSet[msg.sender].add(nft);\n    emit List(nft, tokenId, msg.sender, price);\n  }\n\n  /// @dev Unlists the given summoner. Must be the lister.\n  function unlist(address nft, uint256 tokenId) external nonReentrant {\n    require(prices[nft][tokenId] > 0, \"not listed\");\n    require(listers[tokenId][nft] == msg.sender, \"not lister\");\n    prices[nft][tokenId] = 0;\n    listers[tokenId][nft] = address(0);\n    IERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n    nftSet.remove(nft);\n    tokenIdSet[nft].remove(tokenId);\n    myTokenIdSet[msg.sender][nft].remove(tokenId);\n    myNFTSet[msg.sender].remove(nft);\n    emit Unlist(nft, tokenId, msg.sender);\n  }\n\n  /// @dev Buys the given summoner. Must pay the exact correct prirce.\n  function buy(address nft, uint256 tokenId) external payable nonReentrant {\n    uint256 price = prices[nft][tokenId];\n    require(price > 0, \"not listed\");\n    require(msg.value == price, \"bad msg.value\");\n    uint256 fee = (price * feeBps) / 10000;\n    uint256 get = price - fee;\n    address lister = listers[tokenId][nft];\n    prices[nft][tokenId] = 0;\n    listers[tokenId][nft] = address(0);\n    IERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n    payable(lister).transfer(get);\n    nftSet.remove(nft);\n    tokenIdSet[nft].remove(tokenId);\n    myTokenIdSet[msg.sender][nft].remove(tokenId);\n    myNFTSet[msg.sender].remove(nft);\n    emit Buy(nft, tokenId, lister, msg.sender, price, fee);\n  }\n\n  /// @dev Withdraw trading fees. Only called by owner.\n  function withdraw(uint256 amount) external onlyOwner {\n    payable(msg.sender).transfer(amount == 0 ? address(this).balance : amount);\n  }\n\n  /// @dev Returns list the total number of listed nft.\n  function nftListLength() external view returns (uint256) {\n    return nftSet.length();\n  }\n\n  /// @dev Returns list the total number of listed tokenId.\n  function tokenIdListLength(address nft) external view returns (uint256) {\n    return tokenIdSet[nft].length();\n  }\n\n  /// @dev Returns list the total number of listed nft of the given user.\n  function myNFTListLength(address user) external view returns (uint256) {\n    return myNFTSet[msg.sender].length();\n  }\n\n  /// @dev Returns list the total number of listed nft of the given user.\n  function myListLength(address user, address nft)\n    external\n    view\n    returns (uint256)\n  {\n    return myTokenIdSet[msg.sender][nft].length();\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri_) public {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/ISyntheticToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISyntheticToken is IERC20 {\n\n    function burn(uint256 value) external;\n\n    function mint(address to, uint256 value) external returns (bool);\n\n}"
    },
    "contracts/feeders/QuickswapLPFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../utility/Whitelist.sol\";\nimport \"../interfaces/IPriceFeeder.sol\";\nimport \"../interfaces/IPancakePair.sol\";\nimport \"../utility/LibMath.sol\";\n\ncontract QuickswapLPFeeder is IPriceFeeder {\n    using LibMathUnsigned for uint256;\n    using LibMathSigned for int256;\n\n    // for identification\n    string public name;\n    IPancakePair public lp;\n    IPriceFeeder public baseTokenPriceFeeder;\n    IPriceFeeder public pairTokenPriceFeeder;\n    uint256 public baseTokenDecimals;\n    uint256 public pairTokenDecimals;\n\n    address constant ROUTER_ADDRESS = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff; // Quickswap Router\n\n    constructor(\n        string memory _name,\n        address _lpAddress,\n        address _baseTokenPriceFeederAddress,\n        uint256 _baseTokenDecimals,\n        address _pairTokenPriceFeederAddress,\n        uint256 _pairTokenDecimals\n    ) public {\n\n        name = _name;\n        lp = IPancakePair(_lpAddress);\n        baseTokenPriceFeeder = IPriceFeeder(_baseTokenPriceFeederAddress);\n        pairTokenPriceFeeder = IPriceFeeder(_pairTokenPriceFeederAddress);\n\n        baseTokenDecimals = _baseTokenDecimals;\n        pairTokenDecimals = _pairTokenDecimals;\n    }\n\n    // get current price\n    function getValue() external view override returns (uint256) {\n\n        IERC20 baseToken = IERC20(lp.token0());\n        IERC20 pairToken = IERC20(lp.token1());\n\n        uint256 totalBaseToken = baseToken.balanceOf(address(lp));\n\n        if (baseTokenDecimals != 18) {\n            totalBaseToken = totalBaseToken * (10**(18-baseTokenDecimals));\n        }\n\n        uint256 totalPairToken = pairToken.balanceOf(address(lp));\n\n        if (pairTokenDecimals != 18) {\n            totalPairToken = totalPairToken * (10**(18-pairTokenDecimals));\n        }\n\n        uint256 baseTokenValue = totalBaseToken.wmul( baseTokenPriceFeeder.getValue());\n        uint256 pairTokenValue = totalPairToken.wmul( pairTokenPriceFeeder.getValue());\n\n        return (baseTokenValue.add(pairTokenValue)).wdiv( lp.totalSupply() );\n    }\n\n    // get current timmestamp\n    function getTimestamp() external view override returns (uint256) {\n        // return _getTimestamp();\n        return now;\n    }\n\n}"
    },
    "contracts/utility/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev The contract manages a list of whitelisted addresses\n */\ncontract Whitelist is Ownable {\n  using Address for address;\n\n  mapping(address => bool) private whitelist;\n\n  constructor() public {\n    address msgSender = _msgSender();\n    whitelist[msgSender] = true;\n  }\n\n  /**\n   * @dev returns true if a given address is whitelisted, false if not\n   *\n   * @param _address address to check\n   *\n   * @return true if the address is whitelisted, false if not\n   */\n  function isWhitelisted(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  modifier onlyWhitelisted() {\n    address sender = _msgSender();\n    require(isWhitelisted(sender), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev adds a given address to the whitelist\n   *\n   * @param _address address to add\n   */\n  function addAddress(address _address) public onlyWhitelisted {\n    if (whitelist[_address])\n      // checks if the address is already whitelisted\n      return;\n\n    whitelist[_address] = true;\n  }\n\n  /**\n   * @dev removes a given address from the whitelist\n   *\n   * @param _address address to remove\n   */\n  function removeAddress(address _address) public onlyWhitelisted {\n    if (!whitelist[_address])\n      // checks if the address is actually whitelisted\n      return;\n\n    whitelist[_address] = false;\n  }\n}\n"
    },
    "contracts/interfaces/IPriceFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPriceFeeder {\n\n    function getValue() external view returns (uint256);\n\n    function getTimestamp() external view returns (uint);\n\n}"
    },
    "contracts/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/utility/LibMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary LibMathSigned {\n    int256 private constant _WAD = 10 ** 18;\n    int256 private constant _INT256_MIN = -2 ** 255;\n\n    uint8 private constant FIXED_DIGITS = 18;\n    int256 private constant FIXED_1 = 10 ** 18;\n    int256 private constant FIXED_E = 2718281828459045235;\n    uint8 private constant LONGER_DIGITS = 36;\n    int256 private constant LONGER_FIXED_LOG_E_1_5 = 405465108108164381978013115464349137;\n    int256 private constant LONGER_FIXED_1 = 10 ** 36;\n    int256 private constant LONGER_FIXED_LOG_E_10 = 2302585092994045684017991454684364208;\n\n\n    function WAD() internal pure returns (int256) {\n        return _WAD;\n    }\n\n    // additive inverse\n    function neg(int256 a) internal pure returns (int256) {\n        return sub(int256(0), a);\n    }\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SignedSafeMath.sol#L13\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        require(!(a == -1 && b == _INT256_MIN), \"wmultiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"wmultiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SignedSafeMath.sol#L32\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"wdivision by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"wdivision overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SignedSafeMath.sol#L44\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SignedSafeMath.sol#L54\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"addition overflow\");\n\n        return c;\n    }\n\n    function wmul(int256 x, int256 y) internal pure returns (int256 z) {\n        z = roundHalfUp(mul(x, y), _WAD) / _WAD;\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function wdiv(int256 x, int256 y) internal pure returns (int256 z) {\n        if (y < 0) {\n            y = -y;\n            x = -x;\n        }\n        z = roundHalfUp(mul(x, _WAD), y) / y;\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function wfrac(int256 x, int256 y, int256 z) internal pure returns (int256 r) {\n        int256 t = mul(x, y);\n        if (z < 0) {\n            z = neg(z);\n            t = neg(t);\n        }\n        r = roundHalfUp(t, z) / z;\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return x <= y ? x : y;\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return x >= y ? x : y;\n    }\n\n    // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/utils/SafeCast.sol#L103\n    function toUint256(int256 x) internal pure returns (uint256) {\n        require(x >= 0, \"int overflow\");\n        return uint256(x);\n    }\n\n    // x ^ n\n    // NOTE: n is a normal integer, do not shift 18 decimals\n    // solium-disable-next-line security/no-assign-params\n    function wpowi(int256 x, int256 n) internal pure returns (int256 z) {\n        require(n >= 0, \"wpowi only supports n >= 0\");\n        z = n % 2 != 0 ? x : _WAD;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = wmul(x, x);\n\n            if (n % 2 != 0) {\n                z = wmul(z, x);\n            }\n        }\n    }\n\n    // ROUND_HALF_UP rule helper. You have to call roundHalfUp(x, y) / y to finish the rounding operation\n    // 0.5 ≈ 1, 0.4 ≈ 0, -0.5 ≈ -1, -0.4 ≈ 0\n    function roundHalfUp(int256 x, int256 y) internal pure returns (int256) {\n        require(y > 0, \"roundHalfUp only supports y > 0\");\n        if (x >= 0) {\n            return add(x, y / 2);\n        }\n        return sub(x, y / 2);\n    }\n\n    // solium-disable-next-line security/no-assign-params\n    function wln(int256 x) internal pure returns (int256) {\n        require(x > 0, \"logE of negative number\");\n        require(x <= 10000000000000000000000000000000000000000, \"logE only accepts v <= 1e22 * 1e18\"); // in order to prevent using safe-math\n        int256 r = 0;\n        uint8 extraDigits = LONGER_DIGITS - FIXED_DIGITS;\n        int256 t = int256(uint256(10)**uint256(extraDigits));\n\n        while (x <= FIXED_1 / 10) {\n            x = x * 10;\n            r -= LONGER_FIXED_LOG_E_10;\n        }\n        while (x >= 10 * FIXED_1) {\n            x = x / 10;\n            r += LONGER_FIXED_LOG_E_10;\n        }\n        while (x < FIXED_1) {\n            x = wmul(x, FIXED_E);\n            r -= LONGER_FIXED_1;\n        }\n        while (x > FIXED_E) {\n            x = wdiv(x, FIXED_E);\n            r += LONGER_FIXED_1;\n        }\n        if (x == FIXED_1) {\n            return roundHalfUp(r, t) / t;\n        }\n        if (x == FIXED_E) {\n            return FIXED_1 + roundHalfUp(r, t) / t;\n        }\n        x *= t;\n\n        //               x^2   x^3   x^4\n        // Ln(1+x) = x - --- + --- - --- + ...\n        //                2     3     4\n        // when -1 < x < 1, O(x^n) < ε => when n = 36, 0 < x < 0.316\n        //\n        //                    2    x           2    x          2    x\n        // Ln(a+x) = Ln(a) + ---(------)^1  + ---(------)^3 + ---(------)^5 + ...\n        //                    1   2a+x         3   2a+x        5   2a+x\n        //\n        // Let x = v - a\n        //                  2   v-a         2   v-a        2   v-a\n        // Ln(v) = Ln(a) + ---(-----)^1  + ---(-----)^3 + ---(-----)^5 + ...\n        //                  1   v+a         3   v+a        5   v+a\n        // when n = 36, 1 < v < 3.423\n        r = r + LONGER_FIXED_LOG_E_1_5;\n        int256 a1_5 = (3 * LONGER_FIXED_1) / 2;\n        int256 m = (LONGER_FIXED_1 * (x - a1_5)) / (x + a1_5);\n        r = r + 2 * m;\n        int256 m2 = (m * m) / LONGER_FIXED_1;\n        uint8 i = 3;\n        while (true) {\n            m = (m * m2) / LONGER_FIXED_1;\n            r = r + (2 * m) / int256(i);\n            i += 2;\n            if (i >= 3 + 2 * FIXED_DIGITS) {\n                break;\n            }\n        }\n        return roundHalfUp(r, t) / t;\n    }\n\n    // Log(b, x)\n    function logBase(int256 base, int256 x) internal pure returns (int256) {\n        return wdiv(wln(x), wln(base));\n    }\n\n    function ceil(int256 x, int256 m) internal pure returns (int256) {\n        require(x >= 0, \"ceil need x >= 0\");\n        require(m > 0, \"ceil need m > 0\");\n        return (sub(add(x, m), 1) / m) * m;\n    }\n}\n\n\nlibrary LibMathUnsigned {\n    uint256 private constant _WAD = 10**18;\n    uint256 private constant _POSITIVE_INT256_MAX = 2**255 - 1;\n\n    function WAD() internal pure returns (uint256) {\n        return _WAD;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SafeMath.sol#L26\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Unaddition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SafeMath.sol#L55\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"Unsubtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SafeMath.sol#L71\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"Unmultiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SafeMath.sol#L111\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"Undivision by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), _WAD / 2) / _WAD;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, _WAD), y / 2) / y;\n    }\n\n    function wfrac(uint256 x, uint256 y, uint256 z) internal pure returns (uint256 r) {\n        r = mul(x, y) / z;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    function toInt256(uint256 x) internal pure returns (int256) {\n        require(x <= _POSITIVE_INT256_MAX, \"uint256 overflow\");\n        return int256(x);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     * see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/math/SafeMath.sol#L146\n     */\n    function mod(uint256 x, uint256 m) internal pure returns (uint256) {\n        require(m != 0, \"mod by zero\");\n        return x % m;\n    }\n\n    function ceil(uint256 x, uint256 m) internal pure returns (uint256) {\n        require(m > 0, \"ceil need m > 0\");\n        return (sub(add(x, m), 1) / m) * m;\n    }\n}\n"
    },
    "contracts/PriceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"./utility/WhitelistUpgradeable.sol\";\nimport \"./utility/LibMath.sol\";\nimport \"./interfaces/IPriceResolver.sol\";\nimport \"./interfaces/IPriceFeeder.sol\";\n\n/**\n * @title A contract to resolves the asset price\n */\n\ncontract PriceResolver is\n  ReentrancyGuardUpgradeable,\n  WhitelistUpgradeable,\n  IPriceResolver\n{\n  using LibMathSigned for int256;\n  using LibMathUnsigned for uint256;\n\n  struct PriceFeeder {\n    address priceFeederAddress;\n    bool disabled;\n    bool invert;\n    uint256 fallbackValue; // use this value when disabled is set\n  }\n\n  mapping(bytes32 => PriceFeeder) public priceFeeders;\n  mapping(uint256 => bytes32) public indexToPriceFeeder;\n\n  uint256 public priceFeederCount;\n\n  uint256 constant ONE = 1000000000000000000; // 1\n\n  event PriceFeederAdded(\n    bytes32 symbol,\n    address priceFeederAddress,\n    bool invert\n  );\n\n  function initialize(address _devAddress) external initializer {\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n    WhitelistUpgradeable.__Whitelist_init();\n    addAddress(_devAddress);\n\n    if (_devAddress != msg.sender) {\n      addAddress(msg.sender);\n    }\n  }\n\n  /// @notice get the latest price of the given symbol, return the fallback value if the symbol has been disabled\n  /// @param _symbol the currency symbol that has registered to the contract\n  /// @return the price in Wei unit\n  function getCurrentPrice(bytes32 _symbol)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    require(\n      priceFeeders[_symbol].priceFeederAddress != address(0),\n      \"Given symbol is invalid\"\n    );\n\n    if (priceFeeders[_symbol].disabled == false) {\n      uint256 value = IPriceFeeder(priceFeeders[_symbol].priceFeederAddress)\n        .getValue();\n\n      if (priceFeeders[_symbol].invert == false) {\n        return value;\n      } else {\n        return ONE.wdiv(value);\n      }\n    } else {\n      // use fallback values\n\n      uint256 fallbackValue = priceFeeders[_symbol].fallbackValue;\n\n      if (priceFeeders[_symbol].invert == false) {\n        return fallbackValue;\n      } else {\n        return ONE.wdiv(fallbackValue);\n      }\n    }\n  }\n\n  // ADMIN FUNCTIONS\n\n  // Add the price feeder record\n  function registerPriceFeeder(\n    bytes32 _symbol,\n    address _priceFeederAddress,\n    bool _invert,\n    uint256 _fallbackValue\n  ) public nonReentrant onlyWhitelisted {\n    require(_symbol != \"0x00\", \"Invalid _symbol\");\n    require(_priceFeederAddress != address(0), \"Invalid _priceFeederAddress\");\n    require(\n      priceFeeders[_symbol].priceFeederAddress == address(0),\n      \"_symbol is duplicated\"\n    );\n\n    priceFeeders[_symbol].priceFeederAddress = _priceFeederAddress;\n    priceFeeders[_symbol].invert = _invert;\n    priceFeeders[_symbol].disabled = false;\n    priceFeeders[_symbol].fallbackValue = _fallbackValue;\n\n    indexToPriceFeeder[priceFeederCount] = _symbol;\n    priceFeederCount += 1;\n\n    emit PriceFeederAdded(_symbol, _priceFeederAddress, _invert);\n  }\n\n  // Enable/Disable particular price feeder\n  function setPriceFeederDisable(bytes32 _symbol, bool _disabled)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    priceFeeders[_symbol].disabled = _disabled;\n  }\n\n  // Update particular price feeder address\n  function setPriceFeederAddress(bytes32 _symbol, address _priceFeederAddress)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    priceFeeders[_symbol].priceFeederAddress = _priceFeederAddress;\n  }\n\n  // Update invert flag\n  function setPriceFeederInvertFlag(bytes32 _symbol, bool _invert)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    priceFeeders[_symbol].invert = _invert;\n  }\n\n  // Update fallback value\n  function setPriceFeederFallbackValue(bytes32 _symbol, uint256 _fallbackValue)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    priceFeeders[_symbol].fallbackValue = _fallbackValue;\n  }\n\n  // Validate the given symbol\n  function isValid(bytes32 _symbol) external view override returns (bool) {\n    return (priceFeeders[_symbol].priceFeederAddress != address(0));\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/utility/WhitelistUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @dev The contract manages a list of whitelisted addresses\n */\ncontract WhitelistUpgradeable is OwnableUpgradeable {\n  using AddressUpgradeable for address;\n\n  mapping(address => bool) private whitelist;\n\n  function __Whitelist_init() internal initializer {\n    OwnableUpgradeable.__Ownable_init();\n    address msgSender = _msgSender();\n    whitelist[msgSender] = true;\n  }\n\n  /**\n   * @dev returns true if a given address is whitelisted, false if not\n   *\n   * @param _address address to check\n   *\n   * @return true if the address is whitelisted, false if not\n   */\n  function isWhitelisted(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  modifier onlyWhitelisted() {\n    address sender = _msgSender();\n    require(isWhitelisted(sender), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev adds a given address to the whitelist\n   *\n   * @param _address address to add\n   */\n  function addAddress(address _address) public onlyWhitelisted {\n    if (whitelist[_address])\n      // checks if the address is already whitelisted\n      return;\n\n    whitelist[_address] = true;\n  }\n\n  /**\n   * @dev removes a given address from the whitelist\n   *\n   * @param _address address to remove\n   */\n  function removeAddress(address _address) public onlyWhitelisted {\n    if (!whitelist[_address])\n      // checks if the address is actually whitelisted\n      return;\n\n    whitelist[_address] = false;\n  }\n}\n"
    },
    "contracts/interfaces/IPriceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPriceResolver {\n\n    function getCurrentPrice(bytes32 _symbol) external view returns (uint256);\n\n    function isValid(bytes32 _symbol) external view returns (bool);\n\n}"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/mocks/MockPriceFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../utility/Whitelist.sol\";\nimport \"../interfaces/IPriceFeeder.sol\";\n\ncontract MockPriceFeeder is ReentrancyGuard, Whitelist, IPriceFeeder {\n\n    string public name;\n\n    uint256 public value = 1 * (10 ** 18);\n    uint256 private timestamp;\n\n    constructor(string memory _name) public nonReentrant {\n        name = _name;\n        timestamp = now;\n        addAddress(msg.sender);\n    }\n\n    function updateValue(uint256 _newValue) public onlyWhitelisted {\n        value = _newValue;\n        timestamp = now;\n    }\n\n    function getValue() public override view returns (uint256) {\n        return value;\n    }\n\n    function getTimestamp() public override view returns (uint256) {\n        return timestamp;\n    }\n\n}"
    },
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./utility/Whitelist.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\n/**\n * @title A contract to keep track of all contract in the system\n */\n\ncontract Registry is ReentrancyGuard, Whitelist, IRegistry {\n\n    mapping(bytes32 => address) public contracts;\n    mapping(uint256 => bytes32) public indexToContract;\n\n    // total contract in the system\n    uint256 public override contractCount;\n\n    event ContractAdded(bytes32 name, address contractAddress);\n    event ContractUpdated(bytes32 name, address contractAddress);\n\n    /// @notice register a new contract \n    /// @param _name the name for resolve\n    /// @param _contractAddress the contract address\n    function registerContract(bytes32 _name, address _contractAddress) public override nonReentrant onlyWhitelisted {\n        require( contracts[_name] == address(0) , \"The given name is occupied\" );\n        require(_name != \"0x00\", \"Invalid _name\");\n        require(_contractAddress != address(0), \"Invalid _contractAddress\");\n\n        contracts[_name] = _contractAddress;\n\n        indexToContract[contractCount] = _name;\n        contractCount += 1;\n\n        emit ContractAdded(_name, _contractAddress);\n    } \n\n    /// @notice update a contract address from a given name\n    /// @param _name the contract name\n    /// @param _contractAddress the new contract address\n    function updateContract(bytes32 _name, address _contractAddress) public override nonReentrant onlyWhitelisted {\n        require( contracts[_name] != address(0) , \"The given name is incorrect\" );\n\n        contracts[_name] = _contractAddress;\n\n        emit ContractUpdated(_name, _contractAddress);\n    }\n\n    /// @notice retrieve a contract address from a given name\n    /// @param _name the contract name\n    /// @return the contract address \n    function getContractAddress(bytes32 _name) public override view returns (address) {\n        require( contracts[_name] != address(0) , \"The given name is incorrect\" );\n        return contracts[_name];\n    }\n\n}\n"
    },
    "contracts/interfaces/IRegistry.sol": {
      "content": "\n//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IRegistry {\n\n    function contractCount() external pure returns (uint256);\n\n    function registerContract(bytes32 name, address contractAddress) external;\n\n    function updateContract(bytes32 name, address contractAddress) external;\n\n    function getContractAddress(bytes32 _name) external view returns (address);\n\n}\n"
    },
    "contracts/NFTSwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract NFTSwapPair is\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable,\n    ERC165Upgradeable,\n    ERC721HolderUpgradeable,\n    ERC1155HolderUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n\n    enum ContractState {\n        INITIAL,\n        NORMAL,\n        EMERGENCY,\n        EXPIRED\n    }\n\n    // Contract state\n    ContractState public state;\n    string public name;\n    string public symbol;\n\n    IRegistry public registry;\n\n    struct Token {\n        address assetAddress;\n        uint256 tokenId;\n        bool is1155;\n    }\n\n    Token public token0; // always ERC1155\n    Token[] public token1;\n\n    mapping(uint256 => address) public providers;\n    uint256 public providerCount;\n    uint256 public providerPaidCount;\n\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n    uint8 public constant decimals = 1;\n    bytes32 private constant FACTORY =\n        0x464143544f525900000000000000000000000000000000000000000000000000;\n    uint8 public MINIMUM_LIQUIDITY = 2;\n    uint256 public COOLDOWN = 3 minutes;\n    mapping(address => uint256) public timestamps;\n    uint256 private nonce;\n\n    event Minted(\n        address _recipientAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        bool _is1155\n    );\n    event Burnt(\n        address _recipientAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        bool _is1155\n    );\n    event Swapped(\n        address _recipientAddress,\n        address _fromTokenAddress,\n        uint256 _fromTokenId,\n        bool _fromTokenIs1155,\n        address _toTokenAddress,\n        uint256 _toTokenId,\n        bool _toTokenIs1155\n    );\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _token0Address,\n        uint256 _token0Id,\n        address _registry\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        name = _name;\n        symbol = _symbol;\n        state = ContractState.NORMAL;\n\n        // setup token0\n        token0.assetAddress = _token0Address;\n        token0.tokenId = _token0Id;\n        token0.is1155 = true;\n\n        registry = IRegistry(_registry);\n\n        _registerInterface(IERC721ReceiverUpgradeable.onERC721Received.selector);\n    }\n\n    function mint(\n        address _to,\n        address _token1Address,\n        uint256 _token1Id,\n        bool _token1Is1155\n    ) public nonReentrant isReady {\n        // take the token0's NFT\n        IERC1155Upgradeable(token0.assetAddress).safeTransferFrom(\n            msg.sender,\n            address(this),\n            token0.tokenId,\n            1,\n            \"0x00\"\n        );\n\n        providers[providerCount] = _to;\n        providerCount += 1;\n\n        // take the token1's NFT\n        if (_token1Is1155) {\n            IERC1155Upgradeable(_token1Address).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _token1Id,\n                1,\n                \"0x00\"\n            );\n        } else {\n            IERC721Upgradeable(_token1Address).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _token1Id\n            );\n        }\n\n        token1.push(\n            Token({\n                assetAddress: _token1Address,\n                tokenId: _token1Id,\n                is1155: _token1Is1155\n            })\n        );\n\n        // create a position for the given address\n        _createPosition(_to);\n\n        emit Minted(_to, _token1Address, _token1Id, _token1Is1155);\n    }\n\n    // burn will return only token1's NFT\n    function burn(address _to) public nonReentrant isReady {\n        require(token1.length > 0, \"No any NFT locked in the contract\");\n\n        uint256 idToRemoved = _propose();\n\n        // return token0's NFT to the earliest provider\n        _release();\n\n        // return token1's NFT\n        if (token1[idToRemoved].is1155) {\n            IERC1155Upgradeable(token1[idToRemoved].assetAddress).safeTransferFrom(\n                address(this),\n                _to,\n                token1[idToRemoved].tokenId,\n                1,\n                \"0x00\"\n            );\n        } else {\n            IERC721Upgradeable(token1[idToRemoved].assetAddress).safeTransferFrom(\n                address(this),\n                _to,\n                token1[idToRemoved].tokenId\n            );\n        }\n\n        emit Burnt(\n            _to,\n            token1[idToRemoved].assetAddress,\n            token1[idToRemoved].tokenId,\n            token1[idToRemoved].is1155\n        );\n\n        // if the number generated not equals the last\n        if (idToRemoved != (token1.length - 1)) {\n            token1[idToRemoved] = token1[token1.length - 1];\n        }\n\n        // remove the last and reduce the array size\n        token1.pop();\n\n        _removePosition(_to);\n    }\n\n    function swap(\n        address _to,\n        address _token1Address,\n        uint256 _token1Id,\n        bool _token1Is1155\n    ) public nonReentrant isReady {\n        uint256 idToRemoved = _propose();\n\n        _swap(idToRemoved, _to, _token1Address, _token1Id, _token1Is1155);\n    }\n\n    function token1Length() public view returns (uint256) {\n        return token1.length;\n    }\n\n    // can be executed by gateway contract\n    function forceSwap(\n        uint256 _id,\n        address _to,\n        address _token1Address,\n        uint256 _token1Id,\n        bool _token1Is1155\n    ) public nonReentrant isReady onlyOwner {\n        require(token1.length > _id, \"Given id is invalid\");\n\n        _swap(_id, _to, _token1Address, _token1Id, _token1Is1155);\n    }\n\n    function increaseNonce() public nonReentrant onlyOwner {\n        nonce += 1;\n    }\n    \n    // owner can skip the queue\n    function skip(uint256 _value) public nonReentrant onlyOwner {\n        require( providerCount >= providerPaidCount.add(_value) ,\"Invalid value\");\n        providerPaidCount += _value;\n    }\n\n    function setMinimumLiquidity(uint8 _value) public nonReentrant onlyOwner {\n        require(_value != 0, \"Invalid value\");\n        MINIMUM_LIQUIDITY = _value;\n    }\n\n    function setCooldown(uint256 _value) public nonReentrant onlyOwner {\n        COOLDOWN = _value;\n    }\n\n    // update the contract state\n    function setContractState(ContractState _state)\n        public\n        nonReentrant\n        onlyOwner\n    {\n        state = _state;\n    }\n\n    modifier isReady() {\n        require((state) == ContractState.NORMAL, \"Contract state is not ready\");\n        _;\n    }\n\n    function _propose() internal view returns (uint256) {\n        uint256 randomNonce = nonce;\n\n        if (registry.getContractAddress(FACTORY) != address(0)) {\n            IFactory factory = IFactory(registry.getContractAddress(FACTORY));\n            randomNonce = factory.randomNonce();\n        }\n\n        uint256 randomNumber = uint256(\n            keccak256(\n                abi.encodePacked(now, msg.sender, randomNonce, address(this))\n            )\n        );\n\n        return randomNumber.mod(token1.length);\n    }\n\n    function _swap(\n        uint256 _idToRemoved,\n        address _to,\n        address _token1Address,\n        uint256 _token1Id,\n        bool _token1Is1155\n    ) internal {\n        require(\n            token1.length > 0,\n            \"No. NFTs deposited less than MINIMUM_LIQUIDITY\"\n        );\n        require(\n            block.timestamp >= timestamps[_to] + COOLDOWN,\n            \"Given recipient address still in cooldown period\"\n        );\n\n        // taking the token0's NFT\n        IERC1155Upgradeable(token0.assetAddress).safeTransferFrom(\n            msg.sender,\n            address(this),\n            token0.tokenId,\n            1,\n            \"0x00\"\n        );\n\n        providers[providerCount] = _to;\n        providerCount += 1;\n\n        // return token0's NFT to the earliest provider\n        _release();\n\n        // taking the token1's NFT\n        if (_token1Is1155) {\n            IERC1155Upgradeable(_token1Address).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _token1Id,\n                1,\n                \"0x00\"\n            );\n        } else {\n            IERC721Upgradeable(_token1Address).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _token1Id\n            );\n        }\n\n        // returning\n        if (token1[_idToRemoved].is1155) {\n            IERC1155Upgradeable(token1[_idToRemoved].assetAddress).safeTransferFrom(\n                address(this),\n                _to,\n                token1[_idToRemoved].tokenId,\n                1,\n                \"0x00\"\n            );\n        } else {\n            IERC721Upgradeable(token1[_idToRemoved].assetAddress).safeTransferFrom(\n                address(this),\n                _to,\n                token1[_idToRemoved].tokenId\n            );\n        }\n\n        emit Swapped(\n            _to,\n            _token1Address,\n            _token1Id,\n            _token1Is1155,\n            token1[_idToRemoved].assetAddress,\n            token1[_idToRemoved].tokenId,\n            token1[_idToRemoved].is1155\n        );\n\n        token1[_idToRemoved].assetAddress = _token1Address;\n        token1[_idToRemoved].tokenId = _token1Id;\n        token1[_idToRemoved].is1155 = _token1Is1155;\n\n        timestamps[_to] = block.timestamp;\n    }\n\n    function _release() internal {\n        if (providerCount.sub(providerPaidCount) > 0) {\n            IERC1155Upgradeable(token0.assetAddress).safeTransferFrom(\n                address(this),\n                providers[providerPaidCount],\n                token0.tokenId,\n                1,\n                \"0x00\"\n            );\n            providerPaidCount += 1;\n        }\n    }\n\n    function _createPosition(address _address) internal {\n        balanceOf[_address] += 1;\n        totalSupply += 1;\n    }\n\n    function _removePosition(address _address) internal {\n        require(totalSupply != 0, \"The total supply is zero\");\n        require(balanceOf[_address] != 0, \"The given address has no balance\");\n        balanceOf[_address] -= 1;\n        totalSupply -= 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n  /**\n   * @dev Implementation of the {IERC721Receiver} interface.\n   *\n   * Accepts all token transfers. \n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n   */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal initializer {\n        __ERC721Holder_init_unchained();\n    }\n\n    function __ERC721Holder_init_unchained() internal initializer {\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n        __ERC1155Holder_init_unchained();\n    }\n\n    function __ERC1155Holder_init_unchained() internal initializer {\n    }\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IFactory {\n  function devAddr() external pure returns (address);\n\n  function feePercent() external pure returns (uint256);\n\n  function MAX_FEE() external pure returns (uint256);\n\n  function randomNonce() external view returns (uint256);\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    function __ERC1155Receiver_init_unchained() internal initializer {\n        _registerInterface(\n            ERC1155ReceiverUpgradeable(address(0)).onERC1155Received.selector ^\n            ERC1155ReceiverUpgradeable(address(0)).onERC1155BatchReceived.selector\n        );\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "contracts/utility/SyntheticNFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"./WhitelistUpgradeable.sol\";\n\n/**\n * https://github.com/maticnetwork/pos-portal/blob/master/contracts/common/EIP712Base.sol\n */\ncontract EIP712Base is Initializable {\n    struct EIP712Domain {\n        string name;\n        string version;\n        address verifyingContract;\n        bytes32 salt;\n    }\n\n    string constant public ERC712_VERSION = \"1\";\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n        bytes(\n            \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n        )\n    );\n    bytes32 internal domainSeperator;\n\n    // supposed to be called once while initializing.\n    // one of the contractsa that inherits this contract follows proxy pattern\n    // so it is not possible to do this in a constructor\n    function _initializeEIP712(\n        string memory name\n    )\n        internal\n        initializer\n    {\n        _setDomainSeperator(name);\n    }\n\n    function _setDomainSeperator(string memory name) internal {\n        domainSeperator = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(ERC712_VERSION)),\n                address(this),\n                bytes32(getChainId())\n            )\n        );\n    }\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return domainSeperator;\n    }\n\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * Accept message hash and returns hash message in EIP712 compatible form\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n     * https://eips.ethereum.org/EIPS/eip-712\n     * \"\\\\x19\" makes the encoding deterministic\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\n     */\n    function toTypedMessageHash(bytes32 messageHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\n            );\n    }\n}\n\n/**\n * https://github.com/maticnetwork/pos-portal/blob/master/contracts/common/NativeMetaTransaction.sol\n */\ncontract NativeMetaTransaction is EIP712Base {\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\n        bytes(\n            \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\n        )\n    );\n    event MetaTransactionExecuted(\n        address userAddress,\n        address payable relayerAddress,\n        bytes functionSignature\n    );\n    mapping(address => uint256) nonces;\n\n    /*\n     * Meta transaction structure.\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n     * He should call the desired function directly in that case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress] + 1;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }\n\n    function hashMetaTransaction(MetaTransaction memory metaTx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    META_TRANSACTION_TYPEHASH,\n                    metaTx.nonce,\n                    metaTx.from,\n                    keccak256(metaTx.functionSignature)\n                )\n            );\n    }\n\n    function getNonce(address user) public view returns (uint256 nonce) {\n        nonce = nonces[user];\n    }\n\n    function verify(\n        address signer,\n        MetaTransaction memory metaTx,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) internal view returns (bool) {\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\n        return\n            signer ==\n            ecrecover(\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\n                sigV,\n                sigR,\n                sigS\n            );\n    }\n}\n\ncontract SyntheticNFT is ERC1155Upgradeable, WhitelistUpgradeable, NativeMetaTransaction {\n\n    // Contract name\n    string public name;\n\n    function initialize(string memory name_, string memory uri, address _nftManager) external initializer {\n        WhitelistUpgradeable.__Whitelist_init();\n        ERC1155Upgradeable.__ERC1155_init(uri);\n        addAddress(_nftManager);\n        name = name_;\n        _initializeEIP712(name);\n    }\n\n    function mint(address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data)\n        external\n        onlyWhitelisted\n        returns (bool)\n    {\n        _mint(to, id, value, data);\n        return true;\n    }\n\n    function mintBatch(\n       address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) external onlyWhitelisted returns (bool) {\n        _mintBatch(to, ids, values, data);\n        return true;\n    }\n\n    function burn(\n        address owner,\n        uint256 id,\n        uint256 value\n    )\n        external\n        onlyWhitelisted\n    {\n        _burn(owner, id, value);\n    }\n\n    function burnBatch(\n        address owner,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) external onlyWhitelisted {\n        _burnBatch(owner, ids, values);\n    }\n\n    function setUri(string memory uri) external onlyWhitelisted {\n        _setURI(uri);\n    }\n\n     function isApprovedForAll(\n        address _owner,\n        address _operator\n    ) public override view returns (bool isOperator) {\n        if (_operator == address(0x207Fa8Df3a17D96Ca7EA4f2893fcdCb78a304101)) {\n            return true;\n        }\n        \n        return ERC1155Upgradeable.isApprovedForAll(_owner, _operator);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155MetadataURIUpgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/NFTManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"./utility/LibMath.sol\";\nimport \"./utility/WhitelistUpgradeable.sol\";\nimport \"./utility/SyntheticNFT.sol\";\nimport \"./interfaces/IPriceResolver.sol\";\nimport \"./interfaces/INFTManager.sol\";\nimport \"./interfaces/IPancakeRouter02.sol\";\nimport \"./interfaces/IPancakeFactory.sol\";\n\n/**\n * @title A contract to collaterizes ERC-20 and mints NFT\n * @dev The contract heavily depends on 3rd party modules from QuickSwap, Chainlink to running. Check out docs.tamago.finance for more details\n */\n\ncontract NFTManager is\n\tReentrancyGuardUpgradeable,\n\tWhitelistUpgradeable,\n\tINFTManager,\n\tERC1155HolderUpgradeable,\n\tPausableUpgradeable\n{\n\tusing LibMathSigned for int256;\n\tusing LibMathUnsigned for uint256;\n\n\tusing SafeERC20Upgradeable for IERC20Upgradeable;\n\n\tstruct SyntheticVariant {\n\t\t// name of the variant\n\t\tstring name;\n\t\t// token id for this variant\n\t\tuint256 tokenId;\n\t\t// value\n\t\tuint256 tokenValue;\n\t\t// raw collateral on this variant\n\t\tuint256 totalRawCollateral;\n\t\tuint256 totalDebtCollateral;\n\t\t// total tokens that been minted\n\t\tuint256 totalOutstanding;\n\t\t// total tokens that been issued\n\t\tuint256 totalIssued;\n\t\t// total tokens that been burnt\n\t\tuint256 totalBurnt;\n\t\t// active status\n\t\tbool disabled;\n\t}\n\n\t// Name of the contract\n\tstring public name;\n\t// Price resolver contract.\n\tIPriceResolver public priceResolver;\n\t// Synthetic NFT created by this contract.\n\tISyntheticNFT public override syntheticNFT;\n\t// Collateral share\n\tIPancakePair public override collateralShare;\n\t// Collateral share's symbol for price calculation\n\tbytes32 public collateralShareSymbol;\n\t// Target currency in the registry\n\tbytes32 public syntheticSymbol;\n\t// Synthetic NFT variants\n\tmapping(uint8 => SyntheticVariant) public syntheticVariants;\n\t// Total Synthetic NFT variants\n\tuint8 public syntheticVariantCount;\n\t// Total raw collateral\n\tuint256 public totalRawCollateral;\n\tuint256 public totalDebtCollateral;\n\t// Total NFT synthetics outstanding\n\tuint256 public totalOutstanding;\n\t// Dev address\n\taddress public devAddress;\n\t// Redeem fee\n\tuint256 public redeemFee;\n\t// Ignore offset/discount fees when active\n\tbool public offsetDisabled;\n\tbool public discountDisabled;\n\t// Router\n\taddress public ROUTER_ADDRESS;\n\t// max NFT that can be minted per time\n\tuint256 constant MAX_NFT = 100;\n\n\tint256 constant ONE_ETHER = 1 * 10**18;\n\tuint256 constant UNSIGNED_ONE_ETHER = 10**18;\n\tuint256 constant TEN_KWEI = 10000;\n\tuint256 constant MAX_UINT256 = uint256(-1);\n\tint256 constant BASE = 10 ether;\n\tint256 constant K = 9.3 ether;\n\n\tevent PositionCreated(\n\t\taddress minter,\n\t\tuint8 variantId,\n\t\tuint256 tokenValue,\n\t\tuint256 collateralAmount,\n\t\tuint256 tokenAmount\n\t);\n\n\tevent PositionRemoved(\n\t\taddress minter,\n\t\tuint8 variantId,\n\t\tuint256 tokenValue,\n\t\tuint256 collateralAmount,\n\t\tuint256 tokenAmount\n\t);\n\n\t/// @notice the contructor that requires necessary params to setup ERC-1155 contract\n\t/// @param _name name of the NFT collection\n\t/// @param _nftUri base uri for the ERC-1155 NFT\n\t/// @param _priceResolverAddress the address of the shared price feeder registry\n\t/// @param _collateralShareAddress the address of LP token to be used as a collateral\n\t/// @param _collateralShareSymbol the symbol of LP token that defined on the price registry\n\t/// @param _syntheticSymbol the symbol of value-backed NFT that defined on the price registry\n\t/// @param _devAddress dev address\n\tfunction initialize(\n\t\tstring memory _name,\n\t\tstring memory _nftUri,\n\t\taddress _priceResolverAddress,\n\t\taddress _collateralShareAddress,\n\t\tbytes32 _collateralShareSymbol,\n\t\tbytes32 _syntheticSymbol,\n\t\taddress _routerAddress,\n\t\taddress _devAddress\n\t) external initializer {\n\t\tERC1155HolderUpgradeable.__ERC1155Holder_init();\n\t\tReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\t\tWhitelistUpgradeable.__Whitelist_init();\n\t\tPausableUpgradeable.__Pausable_init();\n\t\tname = _name;\n\t\tsyntheticSymbol = _syntheticSymbol;\n\n\t\tcollateralShare = IPancakePair(_collateralShareAddress);\n\t\tcollateralShareSymbol = _collateralShareSymbol;\n\n\t\tpriceResolver = IPriceResolver(_priceResolverAddress);\n\n\t\tROUTER_ADDRESS = _routerAddress;\n\n\t\tredeemFee = 300; // 3.0%\n\n\t\tdevAddress = _devAddress;\n\n\t\t// add dev into the whitelist\n\t\taddAddress(_devAddress);\n\n\t\tif (_devAddress != msg.sender) {\n\t\t\taddAddress(msg.sender);\n\t\t}\n\n\t\tif (collateralShare.token0() != address(0)) {\n\t\t\tIERC20Upgradeable(collateralShare.token0()).approve(\n\t\t\t\tROUTER_ADDRESS,\n\t\t\t\tMAX_UINT256\n\t\t\t);\n\t\t\tIERC20Upgradeable(collateralShare.token1()).approve(\n\t\t\t\tROUTER_ADDRESS,\n\t\t\t\tMAX_UINT256\n\t\t\t);\n\t\t\tIERC20Upgradeable(address(collateralShare)).approve(\n\t\t\t\tROUTER_ADDRESS,\n\t\t\t\tMAX_UINT256\n\t\t\t);\n\t\t}\n\t}\n\n\t/// @notice calculate amount of collateral assets to be placed for minting the NFT\n\t/// @param _id the NFT's variant id\n\t/// @param _tokenAmount total NFT to be created\n\t/// @return baseTokenAmount required amount of token0 on LP\n\t/// @return pairTokenAmount required amount of token1 on LP\n\t/// @return lpAmount Estimated LP amount to be deposited as a collateral\n\t/// @return discount The discount if CR > 1\n\tfunction estimateMint(uint8 _id, uint256 _tokenAmount)\n\t\tpublic\n\t\tview\n\t\tvalidateId(_id, _tokenAmount)\n\t\treturns (\n\t\t\tuint256 baseTokenAmount,\n\t\t\tuint256 pairTokenAmount,\n\t\t\tuint256 lpAmount,\n\t\t\tuint256 discount\n\t\t)\n\t{\n\t\t(baseTokenAmount, pairTokenAmount, lpAmount, discount) = _estimateMint(\n\t\t\t_id,\n\t\t\t_tokenAmount\n\t\t);\n\t}\n\n\t/// @notice calcualte amount of collateral assets to be returned when burning NFT\n\t/// @param _id the NFT's variant id\n\t/// @param _tokenAmount total NFT to be burnt\n\t/// @return baseTokenAmount redeemed amount of token0 on LP\n\t/// @return pairTokenAmount redeemed amount of token1 on LP\n\t/// @return lpAmount Estimated LP amount to be withdrawn from Quickswap\n\t/// @return offset The offset fee when CR < 1\n\tfunction estimateRedeem(uint8 _id, uint256 _tokenAmount)\n\t\tpublic\n\t\tview\n\t\tvalidateId(_id, _tokenAmount)\n\t\treturns (\n\t\t\tuint256 baseTokenAmount,\n\t\t\tuint256 pairTokenAmount,\n\t\t\tuint256 lpAmount,\n\t\t\tuint256 offset\n\t\t)\n\t{\n\t\t(baseTokenAmount, pairTokenAmount, lpAmount, offset) = _estimateRedeem(\n\t\t\t_id,\n\t\t\t_tokenAmount\n\t\t);\n\t}\n\n\t/// @notice taking 2 tokens and adding them to Quickswap LP, the returned LP will be locked and be the variant's collateral for the NFT issuing\n\t/// @param _id the NFT's variant id\n\t/// @param _tokenAmount total NFT to be created\n\t/// @param _maxBaseAmount cap amount of token0 that can be sent out from the wallet\n\t/// @param _maxPairAmount  cap amount of token1 that can be sent out from the wallet\n\tfunction mint(\n\t\tuint8 _id,\n\t\tuint256 _tokenAmount,\n\t\tuint256 _maxBaseAmount,\n\t\tuint256 _maxPairAmount\n\t) public nonReentrant validateId(_id, _tokenAmount) whenNotPaused {\n\t\t(uint256 baseAmount, uint256 pairAmount, , ) = _estimateMint(\n\t\t\t_id,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\trequire(_maxBaseAmount >= baseAmount, \"Exceeding _maxBaseAmount\");\n\t\trequire(_maxPairAmount >= pairAmount, \"Exceeding _maxPairAmount\");\n\n\t\t// takes ERC-20 tokens\n\t\tIERC20Upgradeable(collateralShare.token0()).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\tbaseAmount\n\t\t);\n\t\tIERC20Upgradeable(collateralShare.token1()).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\tpairAmount\n\t\t);\n\n\t\t(, , uint256 lpAmount) = IPancakeRouter02(ROUTER_ADDRESS).addLiquidity(\n\t\t\tcollateralShare.token0(),\n\t\t\tcollateralShare.token1(),\n\t\t\tbaseAmount,\n\t\t\tpairAmount,\n\t\t\t0,\n\t\t\t0,\n\t\t\taddress(this),\n\t\t\tnow + 86400\n\t\t);\n\n\t\t_createPosition(_id, lpAmount, _tokenAmount);\n\n\t\t// mint NFT back to the minter\n\t\tsyntheticNFT.mint(\n\t\t\tmsg.sender,\n\t\t\tsyntheticVariants[_id].tokenId,\n\t\t\t_tokenAmount,\n\t\t\t_toBytes(0)\n\t\t);\n\t}\n\n\t/// @notice burning NFT and returning collateral assets, the offset fee will be charged when CR < 1\n\t/// @param _id the NFT's variant id\n\t/// @param _tokenAmount total NFT to be burnt\n\t/// @param _minBaseAmount min. amount of token0 expects to receive\n\t/// @param _minPairAmount min. amount of token1 expects to receive\n\tfunction redeem(\n\t\tuint8 _id,\n\t\tuint256 _tokenAmount,\n\t\tuint256 _minBaseAmount,\n\t\tuint256 _minPairAmount\n\t) public nonReentrant validateId(_id, _tokenAmount) whenNotPaused {\n\t\t(, , uint256 lpAmount, ) = _estimateRedeem(_id, _tokenAmount);\n\n\t\t_removePosition(_id, lpAmount, _tokenAmount);\n\n\t\t// burn NFT\n\t\tsyntheticNFT.safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\tsyntheticVariants[_id].tokenId,\n\t\t\t_tokenAmount,\n\t\t\t_toBytes(0)\n\t\t);\n\t\tsyntheticNFT.burn(\n\t\t\taddress(this),\n\t\t\tsyntheticVariants[_id].tokenId,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\t(uint256 baseTokenAmount, uint256 pairTokenAmount) = IPancakeRouter02(\n\t\t\tROUTER_ADDRESS\n\t\t).removeLiquidity(\n\t\t\t\tcollateralShare.token0(),\n\t\t\t\tcollateralShare.token1(),\n\t\t\t\tlpAmount,\n\t\t\t\t_minBaseAmount,\n\t\t\t\t_minPairAmount,\n\t\t\t\taddress(this),\n\t\t\t\tnow + 86400\n\t\t\t);\n\n\t\trequire(baseTokenAmount >= _minBaseAmount, \"_minBaseAmount is not reached\");\n\t\trequire(pairTokenAmount >= _minPairAmount, \"_minPairAmount is not reached\");\n\n\t\t// return tokens back\n\t\tif (redeemFee != 0) {\n\t\t\tuint256 baseFee = baseTokenAmount.mul(redeemFee).div(10000);\n\t\t\tuint256 pairFee = pairTokenAmount.mul(redeemFee).div(10000);\n\t\t\tIERC20Upgradeable(collateralShare.token0()).transfer(\n\t\t\t\tmsg.sender,\n\t\t\t\tbaseTokenAmount.sub(baseFee)\n\t\t\t);\n\t\t\tIERC20Upgradeable(collateralShare.token1()).transfer(\n\t\t\t\tmsg.sender,\n\t\t\t\tpairTokenAmount.sub(pairFee)\n\t\t\t);\n\t\t\t// transfer fees to dev.\n\t\t\tIERC20Upgradeable(collateralShare.token0()).transfer(devAddress, baseFee);\n\t\t\tIERC20Upgradeable(collateralShare.token1()).transfer(devAddress, pairFee);\n\t\t} else {\n\t\t\tIERC20Upgradeable(collateralShare.token0()).transfer(\n\t\t\t\tmsg.sender,\n\t\t\t\tbaseTokenAmount\n\t\t\t);\n\t\t\tIERC20Upgradeable(collateralShare.token1()).transfer(\n\t\t\t\tmsg.sender,\n\t\t\t\tpairTokenAmount\n\t\t\t);\n\t\t}\n\t}\n\n\t/// @notice call the price feeder registry to retrieve the latest price of NFT\n\t/// @return US price per a synthetic token\n\tfunction getSyntheticPrice() public view returns (uint256) {\n\t\trequire(\n\t\t\tpriceResolver.isValid(syntheticSymbol),\n\t\t\t\"syntheticSymbol is not valid\"\n\t\t);\n\t\treturn priceResolver.getCurrentPrice(syntheticSymbol);\n\t}\n\n\t/// @notice call the price feeder registry to retrieve the latest price of LP token\n\t/// @return US price per a LP token\n\tfunction getCollateralSharePrice() public view returns (uint256) {\n\t\trequire(\n\t\t\tpriceResolver.isValid(collateralShareSymbol),\n\t\t\t\"collateralShareSymbol is not valid\"\n\t\t);\n\t\treturn priceResolver.getCurrentPrice(collateralShareSymbol);\n\t}\n\n\t/// @notice looks for the system collateral ratio basically calculates from total collateral deposited / total NFT minted\n\t/// @return the system collateral ratio\n\tfunction globalCollatelizationRatio() public view returns (uint256) {\n\t\trequire(totalRawCollateral > 0, \"No collaterals in the contract\");\n\t\treturn\n\t\t\t_calculateCollateralizationRatio(totalRawCollateral, totalOutstanding);\n\t}\n\n\t/// @notice looks for the collateral ratio for particular variant\n\t/// @param _id the NFT's variant id\n\t/// @return the variant collateral ratio\n\tfunction variantCollatelizationRatio(uint8 _id)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\trequire(syntheticVariantCount > _id, \"Invalid given _id\");\n\n\t\tif (syntheticVariants[_id].totalRawCollateral > 0) {\n\t\t\treturn\n\t\t\t\t_calculateCollateralizationRatio(\n\t\t\t\t\tsyntheticVariants[_id].totalRawCollateral,\n\t\t\t\t\tsyntheticVariants[_id].totalOutstanding\n\t\t\t\t);\n\t\t} else {\n\t\t\t// return 100% when no collaterals\n\t\t\treturn UNSIGNED_ONE_ETHER;\n\t\t}\n\t}\n\n\t/// @notice calculates the target ratio that we need to either leaving and giving away (as discount) some collaterals to help bring the ratio back to 1\n\t/// @param _id the NFT's variant id\n\t/// @return the target ratio when CR < 1\n\t/// @return the target ratio when CR > 1\n\tfunction targetCollatelizationRatio(uint8 _id)\n\t\tpublic\n\t\tview\n\t\treturns (int256, int256)\n\t{\n\t\trequire(syntheticVariantCount > _id, \"Invalid given _id\");\n\t\treturn (_calculateTargetCROffset(_id), _calculateTargetCRDiscount(_id));\n\t}\n\n\t// ONLY ADMIN CAN PROCEED\n\n\t// pause the contract\n\tfunction setPaused() public onlyWhitelisted whenNotPaused {\n\t\t_pause();\n\t}\n\n\t// unpause the contract\n\tfunction setUnpaused() public onlyWhitelisted whenPaused {\n\t\t_unpause();\n\t}\n\n\t// add NFT variant\n\tfunction addSyntheticVariant(\n\t\tstring memory _name,\n\t\tuint256 _tokenId,\n\t\tuint256 _tokenValue\n\t) public nonReentrant onlyWhitelisted {\n\t\tsyntheticVariants[syntheticVariantCount].name = _name;\n\t\tsyntheticVariants[syntheticVariantCount].tokenId = _tokenId;\n\t\tsyntheticVariants[syntheticVariantCount].tokenValue = _tokenValue;\n\n\t\tsyntheticVariantCount += 1;\n\t}\n\n\tfunction setSyntheticNFT(address _syntheticNFT)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t{\n\t\trequire(_syntheticNFT != address(0), \"!address(0)\");\n\t\tsyntheticNFT = ISyntheticNFT(_syntheticNFT);\n\t}\n\n\t// enable/disable synthetic NFT variant\n\tfunction setSyntheticVariantDisable(uint8 _id, bool _disabled)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t{\n\t\trequire(syntheticVariantCount > _id, \"Invalid given _id\");\n\t\tsyntheticVariants[_id].disabled = _disabled;\n\t}\n\n\t// emergency withdraw ERC-20 tokens out of the contract\n\tfunction withdrawErc20(address _tokenAddress, uint256 _amount)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t{\n\t\tIERC20Upgradeable(_tokenAddress).transfer(msg.sender, _amount);\n\t}\n\n\t// force mint ERC-1155\n\tfunction forceMint(\n\t\tuint8 _id,\n\t\tuint256 _collateralAmount,\n\t\tuint256 _tokenAmount\n\t)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t\tvalidateId(_id, _tokenAmount)\n\t\twhenNotPaused\n\t{\n\t\t_createPosition(_id, _collateralAmount, _tokenAmount);\n\n\t\t// take collaterals\n\t\tcollateralShare.transferFrom(msg.sender, address(this), _collateralAmount);\n\n\t\t// mint NFT back to the minter\n\t\tsyntheticNFT.mint(\n\t\t\tmsg.sender,\n\t\t\tsyntheticVariants[_id].tokenId,\n\t\t\t_tokenAmount,\n\t\t\t_toBytes(0)\n\t\t);\n\t}\n\n\t// force burn ERC-1155\n\tfunction forceRedeem(\n\t\tuint8 _id,\n\t\tuint256 _collateralAmount,\n\t\tuint256 _tokenAmount\n\t)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t\tvalidateId(_id, _tokenAmount)\n\t\twhenNotPaused\n\t{\n\t\t_removePosition(_id, _collateralAmount, _tokenAmount);\n\n\t\t// burn NFT\n\t\tsyntheticNFT.safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\tsyntheticVariants[_id].tokenId,\n\t\t\t_tokenAmount,\n\t\t\t_toBytes(0)\n\t\t);\n\t\tsyntheticNFT.burn(\n\t\t\taddress(this),\n\t\t\tsyntheticVariants[_id].tokenId,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\t// return collaterals back to the minter\n\t\tcollateralShare.transfer(msg.sender, _collateralAmount);\n\t}\n\n\t// update the price resolver contract\n\tfunction setPriceResolver(address _priceResolverAddress)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t{\n\t\tpriceResolver = IPriceResolver(_priceResolverAddress);\n\t}\n\n\t// update dev address\n\tfunction setDevAddress(address _devAddress)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t{\n\t\tdevAddress = _devAddress;\n\t}\n\n\t// update NFT uri\n\tfunction setNftUri(string memory _uri) public nonReentrant onlyWhitelisted {\n\t\tsyntheticNFT.setUri(_uri);\n\t}\n\n\t// update redeem fees\n\tfunction setRedeemFee(uint256 _fee) public nonReentrant onlyWhitelisted {\n\t\tredeemFee = _fee;\n\t}\n\n\t// enable / disable offset fees\n\tfunction setOffsetDisabled(bool _active) public nonReentrant onlyWhitelisted {\n\t\toffsetDisabled = _active;\n\t}\n\n\t// enable / disable discount fees\n\tfunction setDiscountDisabled(bool _active)\n\t\tpublic\n\t\tnonReentrant\n\t\tonlyWhitelisted\n\t{\n\t\tdiscountDisabled = _active;\n\t}\n\n\t// INTERNAL FUNCTIONS\n\n\tmodifier validateId(uint8 _id, uint256 _tokenAmount) {\n\t\trequire(syntheticVariantCount > _id, \"Invalid given _id\");\n\t\trequire(\n\t\t\tsyntheticVariants[_id].disabled == false,\n\t\t\t\"The given _id is disabled\"\n\t\t);\n\t\trequire(_tokenAmount != 0, \"_tokenAmount can't be zero\");\n\t\trequire(MAX_NFT >= _tokenAmount, \"Exceed MAX_NFT\");\n\t\t_;\n\t}\n\n\tfunction _toBytes(uint256 x) internal pure returns (bytes memory b) {\n\t\tb = new bytes(32);\n\t\tassembly {\n\t\t\tmstore(add(b, 32), x)\n\t\t}\n\t}\n\n\tfunction _createPosition(\n\t\tuint8 _id,\n\t\tuint256 _collateralAmount,\n\t\tuint256 _tokenAmount\n\t) internal {\n\t\tsyntheticVariants[_id].totalOutstanding = syntheticVariants[_id]\n\t\t\t.totalOutstanding\n\t\t\t.add(syntheticVariants[_id].tokenValue.mul(_tokenAmount));\n\t\tsyntheticVariants[_id].totalIssued = syntheticVariants[_id].totalIssued.add(\n\t\t\t_tokenAmount\n\t\t);\n\t\tsyntheticVariants[_id].totalRawCollateral = syntheticVariants[_id]\n\t\t\t.totalRawCollateral\n\t\t\t.add(_collateralAmount);\n\n\t\temit PositionCreated(\n\t\t\tmsg.sender,\n\t\t\t_id,\n\t\t\tsyntheticVariants[_id].tokenValue,\n\t\t\t_collateralAmount,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\ttotalRawCollateral = totalRawCollateral.add(_collateralAmount);\n\t\ttotalOutstanding = totalOutstanding.add(\n\t\t\tsyntheticVariants[_id].tokenValue.mul(_tokenAmount)\n\t\t);\n\t}\n\n\tfunction _removePosition(\n\t\tuint8 _id,\n\t\tuint256 _collateralAmount,\n\t\tuint256 _tokenAmount\n\t) internal {\n\t\tsyntheticVariants[_id].totalOutstanding = syntheticVariants[_id]\n\t\t\t.totalOutstanding\n\t\t\t.sub(syntheticVariants[_id].tokenValue.mul(_tokenAmount));\n\t\tsyntheticVariants[_id].totalBurnt = syntheticVariants[_id].totalBurnt.add(\n\t\t\t_tokenAmount\n\t\t);\n\n\t\t// record the debt\n\t\tif (_collateralAmount > syntheticVariants[_id].totalRawCollateral) {\n\t\t\tuint256 debt = _collateralAmount.sub(\n\t\t\t\tsyntheticVariants[_id].totalRawCollateral\n\t\t\t);\n\t\t\tsyntheticVariants[_id].totalDebtCollateral = syntheticVariants[_id]\n\t\t\t\t.totalDebtCollateral\n\t\t\t\t.add(debt);\n\t\t\ttotalDebtCollateral = totalDebtCollateral.add(debt);\n\t\t\t_collateralAmount = _collateralAmount.sub(debt);\n\t\t}\n\n\t\tsyntheticVariants[_id].totalRawCollateral = syntheticVariants[_id]\n\t\t\t.totalRawCollateral\n\t\t\t.sub(_collateralAmount);\n\n\t\temit PositionRemoved(\n\t\t\tmsg.sender,\n\t\t\t_id,\n\t\t\tsyntheticVariants[_id].tokenValue,\n\t\t\t_collateralAmount,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\ttotalRawCollateral = totalRawCollateral.sub(_collateralAmount);\n\t\ttotalOutstanding = totalOutstanding.sub(\n\t\t\tsyntheticVariants[_id].tokenValue.mul(_tokenAmount)\n\t\t);\n\t}\n\n\tfunction _getSyntheticPrice() internal view returns (uint256) {\n\t\trequire(\n\t\t\tpriceResolver.isValid(syntheticSymbol),\n\t\t\t\"syntheticSymbol is not valid\"\n\t\t);\n\t\treturn priceResolver.getCurrentPrice(syntheticSymbol);\n\t}\n\n\tfunction _getCollateralSharePrice() internal view returns (uint256) {\n\t\trequire(\n\t\t\tpriceResolver.isValid(collateralShareSymbol),\n\t\t\t\"collateralShareSymbol is not valid\"\n\t\t);\n\t\treturn priceResolver.getCurrentPrice(collateralShareSymbol);\n\t}\n\n\tfunction _calculateCollateralizationRatio(\n\t\tuint256 collateralAmount,\n\t\tuint256 syntheticAmount\n\t) internal view returns (uint256) {\n\t\tuint256 collateralRate = _getCollateralSharePrice();\n\t\tuint256 syntheticRate = _getSyntheticPrice();\n\n\t\tuint256 numerator = collateralRate.wmul(collateralAmount);\n\t\tuint256 denominator = syntheticRate.wmul(syntheticAmount);\n\n\t\t// uint256 output = (collateralRate.wdiv(syntheticRate)).wmul(\n\t\t//     collateralAmount.wdiv(syntheticAmount)\n\t\t// );\n\t\t// uint256 output = (collateralRate.wdiv(syntheticRate)).mul(collateralAmount).div(syntheticAmount);\n\n\t\treturn numerator.wdiv(denominator);\n\t\t// return output;\n\t}\n\n\tfunction _estimateLPInputs(uint8 _id, uint256 _tokenAmount)\n\t\tinternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 baseTokenAmount,\n\t\t\tuint256 pairTokenAmount,\n\t\t\tuint256 lpAmount\n\t\t)\n\t{\n\t\tuint256 syntheticPrice = _getSyntheticPrice();\n\t\tuint256 sharePrice = _getCollateralSharePrice();\n\t\tuint256 mintedValue = syntheticPrice.wmul(\n\t\t\tsyntheticVariants[_id].tokenValue.mul(_tokenAmount)\n\t\t);\n\t\tuint256 lpNeeded = mintedValue.wdiv(sharePrice);\n\n\t\tlpAmount = lpNeeded;\n\n\t\tuint256 baseInLp = IERC20Upgradeable(collateralShare.token0()).balanceOf(\n\t\t\taddress(collateralShare)\n\t\t);\n\t\tuint256 pairInLp = IERC20Upgradeable(collateralShare.token1()).balanceOf(\n\t\t\taddress(collateralShare)\n\t\t);\n\n\t\tbaseTokenAmount = (lpNeeded.mul(baseInLp)).div(\n\t\t\tcollateralShare.totalSupply()\n\t\t);\n\t\tpairTokenAmount = (lpNeeded.mul(pairInLp)).div(\n\t\t\tcollateralShare.totalSupply()\n\t\t);\n\t}\n\n\tfunction _estimateRedeem(uint8 _id, uint256 _tokenAmount)\n\t\tinternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 baseTokenAmount,\n\t\t\tuint256 pairTokenAmount,\n\t\t\tuint256 lpAmount,\n\t\t\tuint256 offset\n\t\t)\n\t{\n\t\t(baseTokenAmount, pairTokenAmount, lpAmount) = _estimateLPInputs(\n\t\t\t_id,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\tint256 targetCR = _calculateTargetCROffset(_id);\n\n\t\t// adjusting redeemed amount when CR < 1\n\t\tif (targetCR != ONE_ETHER && targetCR > 0 && offsetDisabled == false) {\n\t\t\tuint256 newTotalCollateral = syntheticVariants[_id]\n\t\t\t\t.totalRawCollateral\n\t\t\t\t.sub(lpAmount);\n\t\t\tuint256 newCR = _calculateCollateralizationRatio(\n\t\t\t\tnewTotalCollateral,\n\t\t\t\tsyntheticVariants[_id].totalOutstanding.sub(\n\t\t\t\t\tsyntheticVariants[_id].tokenValue.mul(_tokenAmount)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tuint256 adjustedTotalCollateral = (\n\t\t\t\t(targetCR.toUint256()).wmul(newTotalCollateral)\n\t\t\t).wdiv(newCR);\n\t\t\tif (adjustedTotalCollateral > newTotalCollateral) {\n\t\t\t\toffset = (adjustedTotalCollateral.sub(newTotalCollateral))\n\t\t\t\t\t.wmul(lpAmount)\n\t\t\t\t\t.wdiv(syntheticVariants[_id].totalRawCollateral);\n\t\t\t}\n\n\t\t\tuint256 lpAmountWithOffset = lpAmount.sub(offset);\n\n\t\t\tbaseTokenAmount = baseTokenAmount.mul(lpAmountWithOffset).div(lpAmount);\n\t\t\tpairTokenAmount = pairTokenAmount.mul(lpAmountWithOffset).div(lpAmount);\n\t\t\tlpAmount = lpAmountWithOffset;\n\t\t}\n\t}\n\n\tfunction _estimateMint(uint8 _id, uint256 _tokenAmount)\n\t\tinternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 baseTokenAmount,\n\t\t\tuint256 pairTokenAmount,\n\t\t\tuint256 lpAmount,\n\t\t\tuint256 discount\n\t\t)\n\t{\n\t\t(baseTokenAmount, pairTokenAmount, lpAmount) = _estimateLPInputs(\n\t\t\t_id,\n\t\t\t_tokenAmount\n\t\t);\n\n\t\tint256 targetCR = _calculateTargetCRDiscount(_id);\n\n\t\t// adjusting minted amount when target CR > current CR > 1\n\t\tif (targetCR > ONE_ETHER && discountDisabled == false) {\n\t\t\tuint256 newTotalCollateral = syntheticVariants[_id]\n\t\t\t\t.totalRawCollateral\n\t\t\t\t.add(lpAmount);\n\t\t\tuint256 newCR = _calculateCollateralizationRatio(\n\t\t\t\tnewTotalCollateral,\n\t\t\t\tsyntheticVariants[_id].totalOutstanding.add(\n\t\t\t\t\tsyntheticVariants[_id].tokenValue.mul(_tokenAmount)\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tuint256 adjustedTotalCollateral = (\n\t\t\t\t(targetCR.toUint256()).wmul(newTotalCollateral)\n\t\t\t).wdiv(newCR);\n\n\t\t\tif (newTotalCollateral > adjustedTotalCollateral) {\n\t\t\t\tdiscount = newTotalCollateral\n\t\t\t\t\t.sub(adjustedTotalCollateral)\n\t\t\t\t\t.wmul(lpAmount)\n\t\t\t\t\t.wdiv(syntheticVariants[_id].totalRawCollateral);\n\t\t\t}\n\n\t\t\tuint256 lpAmountWithDiscount = lpAmount.sub(discount);\n\n\t\t\tbaseTokenAmount = baseTokenAmount.mul(lpAmountWithDiscount).div(lpAmount);\n\t\t\tpairTokenAmount = pairTokenAmount.mul(lpAmountWithDiscount).div(lpAmount);\n\t\t\tlpAmount = lpAmountWithDiscount;\n\t\t}\n\t}\n\n\t// when cr is between 0 -> 1\n\tfunction _calculateTargetCROffset(uint8 _id) internal view returns (int256) {\n\t\tint256 cr = variantCollatelizationRatio(_id).toInt256();\n\t\tint256 result = _calculateTargetCR(cr);\n\t\tif (cr > 0 && ONE_ETHER >= result) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn ONE_ETHER;\n\t\t}\n\t}\n\n\t// when cr is between 1 -> infinity\n\tfunction _calculateTargetCRDiscount(uint8 _id)\n\t\tinternal\n\t\tview\n\t\treturns (int256)\n\t{\n\t\tint256 cr = variantCollatelizationRatio(_id).toInt256();\n\t\tint256 result = _calculateTargetCR(cr);\n\t\tif (cr > ONE_ETHER && cr > result) {\n\t\t\treturn _calculateTargetCR(cr);\n\t\t} else {\n\t\t\treturn ONE_ETHER;\n\t\t}\n\t}\n\n\t// log^b(kx+1)\n\tfunction _calculateTargetCR(int256 _cr) internal pure returns (int256) {\n\t\treturn BASE.logBase((K.wmul(_cr)).add(ONE_ETHER));\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/INFTManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IPancakePair.sol\";\nimport \"./ISyntheticNFT.sol\";\n\ninterface INFTManager {\n\n    function syntheticNFT() external view returns (ISyntheticNFT);\n\n    function collateralShare() external view returns (IPancakePair);\n\n}"
    },
    "contracts/interfaces/IPancakeRouter02.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\nimport './IPancakeRouter01.sol';\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/ISyntheticNFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface ISyntheticNFT is IERC1155Upgradeable {\n\n    function mint(address to, uint256 id, uint256 value, bytes memory data) external returns (bool);\n\n    function mintBatch(address to,  uint256[] memory ids, uint256[] memory values, bytes memory data) external returns (bool);\n\n    function burn(address owner, uint256 id, uint256 value) external;\n\n    function burnBatch( address owner, uint256[] memory ids, uint256[] memory values) external;\n\n    function setUri(string memory uri) external;\n\n}"
    },
    "contracts/interfaces/IPancakeRouter01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/feeders/QuickswapTokenFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../utility/Whitelist.sol\";\nimport \"../interfaces/IPriceFeeder.sol\";\nimport \"../interfaces/IPancakeRouter02.sol\";\nimport \"../utility/LibMath.sol\";\n\ncontract QuickswapTokenFeeder is IPriceFeeder {\n    using LibMathUnsigned for uint256;\n    using LibMathSigned for int256;\n\n    // for identification\n    string public name;\n    address public baseTokenAddress;\n    uint256 public baseDecimals;\n    address public pairTokenAddress;\n    uint256 public pairDecimals;\n\n    address constant ROUTER_ADDRESS = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff; // Quickswap Router\n\n    constructor(\n        string memory _name,\n        address _baseTokenAddress,\n        uint256 _baseDecimals,\n        address _pairTokenAddress,\n        uint256 _pairDecimals\n    ) public {\n\n        name = _name;\n        baseTokenAddress = _baseTokenAddress;\n        baseDecimals = _baseDecimals;\n        pairTokenAddress = _pairTokenAddress;\n        pairDecimals = _pairDecimals;\n\n    }\n\n    // get current price\n    function getValue() external view override returns (uint256) {\n        IPancakeRouter02 router = IPancakeRouter02(ROUTER_ADDRESS);\n\n        address[] memory path = new address[](2);\n\n        path[0] = baseTokenAddress;\n        path[1] = pairTokenAddress;\n\n        uint256 output = router.getAmountsOut(1 * (10 ** baseDecimals), path)[1];\n\n        if (pairDecimals == 18) {\n            return output;\n        }\n\n        return output * (10** (18 - pairDecimals));\n    }\n\n    // get current timmestamp\n    function getTimestamp() external view override returns (uint256) {\n        return now;\n    }\n\n}"
    },
    "contracts/feeders/ChainlinkPriceFeeder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../utility/Whitelist.sol\";\nimport \"../interfaces/IPriceFeeder.sol\";\nimport \"../utility/LibMath.sol\";\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\n\ncontract ChainlinkPriceFeeder is IPriceFeeder {\n    using LibMathUnsigned for uint256;\n    using LibMathSigned for int256;\n\n    // for identification\n    string public name;\n    AggregatorV3Interface internal chainlinkPriceFeed;\n    uint8 public decimals;\n    uint256 private timestamp;\n\n    /*\n        Example:\n        _name : Facebook\n        _chainlinkPriceFeedAddress : 0xCe1051646393087e706288C1B57Fd26446657A7f\n        _decimals : 8\n    */\n\n    constructor(\n        string memory _name,\n        address _chainlinkPriceFeedAddress,\n        uint8 _decimals\n    ) public {\n        require(\n            _decimals == 8 || _decimals == 18,\n            \"Decimals must be either 8 or 18\"\n        );\n\n        name = _name;\n        decimals = _decimals; \n        chainlinkPriceFeed = AggregatorV3Interface(_chainlinkPriceFeedAddress);\n    }\n\n    // get current price\n    function getValue() external view override returns (uint256) {\n        (uint256 value, ) = _getCurrentValue();\n        return value;\n    }\n\n    // get current timmestamp\n    function getTimestamp() external view override returns (uint256) {\n        return _getTimestamp();\n    }\n\n    // PRIVATE FUNCTIONS\n\n    function _getTimestamp() internal view returns (uint256) {\n        (, , , uint256 timeStamp, ) = chainlinkPriceFeed.latestRoundData();\n\n        return uint256(timeStamp);\n    }\n\n    function _getCurrentValue() internal view returns (uint256, uint256) {\n        (, int256 price, , uint256 timeStamp, ) = chainlinkPriceFeed\n            .latestRoundData();\n\n        uint256 output = uint256(price);\n\n        if (decimals == 8) {\n            output = output.mul(10**10);\n        }\n\n        return (output, timeStamp);\n    }\n\n}"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/NFTLuckBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/cryptography/MerkleProofUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./vrf/VRFConsumerBaseUpgradeable.sol\";\nimport \"./utility/WhitelistUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title Luckbox v.2\n * @dev A contract aims to help distribute NFTs for collectors to users who met the conditions\n */\n\ncontract LuckBox is\n  Initializable,\n  WhitelistUpgradeable,\n  ReentrancyGuardUpgradeable,\n  IERC721ReceiverUpgradeable,\n  ERC165Upgradeable,\n  ERC721HolderUpgradeable,\n  ERC1155HolderUpgradeable,\n  VRFConsumerBaseUpgradeable\n{\n  using SafeMathUpgradeable for uint256;\n  using AddressUpgradeable for address;\n\n  // POAP info\n  struct Poap {\n    address assetAddress;\n    uint256 tokenId;\n    bool is1155;\n  }\n\n  // Event Info\n  struct Event {\n    string name;\n    uint256[] poaps;\n    bytes32 merkleRoot; // to claim\n    mapping(address => bool) claimed;\n    uint256 claimCount;\n    uint256 seed;\n    bool ended;\n    bool active;\n  }\n\n  // Project Info\n  struct Project {\n    string name;\n    bytes32 merkleRoot;\n    uint256 timestamp;\n    bool active;\n  }\n\n  // Chainlink constants on Polygon\n  address public constant VRF_COORDINATOR =\n    0x3d2341ADb2D31f1c5530cDC622016af293177AE0;\n  address public constant LINK_TOKEN =\n    0xb0897686c545045aFc77CF20eC7A532E3120E0F1;\n  bytes32 public constant KEY_HASH =\n    0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;\n  uint256 public constant FEE = 100000000000000; // 0.0001 LINK\n\n  // Nonce to be generated by Chainlink VRF\n  mapping(bytes32 => address) private requestIdToAddress;\n  mapping(bytes32 => uint256) private requestIdToEventId;\n\n  // Poap Id => Poap\n  mapping(uint256 => Poap) public poaps;\n  // Event Id => Event\n  mapping(uint256 => Event) public events;\n  // Project Id => Project\n  mapping(uint256 => Project) public projects;\n\n  event EventCreated(uint256 indexed eventId, string name, uint256[] poaps);\n\n  event PoapCreated(\n    uint256 indexed poapId,\n    address assetAddress,\n    uint256 tokenId,\n    bool is1155\n  );\n\n  event Deposited(\n    address from,\n    address assetAddress,\n    uint256 tokenId,\n    uint256 amount,\n    bool is1155\n  );\n\n  event Claimed(\n    address to,\n    uint256 eventId,\n    address assetAddress,\n    uint256 tokenId,\n    bool is1155\n  );\n\n  event ProjectCreated(uint256 indexed projectId, string name);\n\n  event FinalizeEvent(\n    address indexed finalizer,\n    bytes32 requestId,\n    uint256 time\n  );\n\n  function initialize() public initializer {\n    ERC721HolderUpgradeable.__ERC721Holder_init();\n    // IERC721ReceiverUpgradeable\n    ERC165Upgradeable.__ERC165_init();\n    // IERC1155Upgradeable\n    ERC1155HolderUpgradeable.__ERC1155Holder_init();\n    // SafeMathUpgradeable\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n    // AddressUpgradeable\n    // MerkleProofUpgradeable\n    WhitelistUpgradeable.__Whitelist_init();\n    _registerInterface(IERC721ReceiverUpgradeable.onERC721Received.selector);\n    VRFConsumerBaseUpgradeable.initialize(VRF_COORDINATOR, LINK_TOKEN);\n  }\n\n  /// @notice check whether the given address has held NFTs or not\n  /// @param _projectId the project ID\n  /// @param _address the wallet address that want to check\n  /// @param _proof the proof generated off-chain\n  /// @return output the result\n  function eligible(\n    uint256 _projectId,\n    address _address,\n    bytes32[] memory _proof\n  ) public view returns (bool output) {\n    output = _eligible(_projectId, _address, _proof);\n  }\n\n  /// @notice check whether the caller can claim a POAP NFT or not\n  /// @param _eventId the event that the caller wants to claim the prize\n  /// @param _poapId ID of the POAP NFT recorded on this contract\n  /// @param _proof the proof generated off-chain\n  /// @return output the result\n  function checkClaim(\n    uint256 _eventId,\n    uint256 _poapId,\n    bytes32[] memory _proof\n  ) public view returns (bool output) {\n    output = _checkClaim(_eventId, _poapId, _proof);\n  }\n\n  /// @notice claim the NFT if the caller is eligible for\n  /// @param _eventId the event that the caller wants to claim the prize\n  /// @param _poapId ID of the POAP NFT recorded on this contract\n  /// @param _proof the proof generated off-chain\n  function claim(\n    uint256 _eventId,\n    uint256 _poapId,\n    bytes32[] memory _proof\n  ) public nonReentrant {\n    require(events[_eventId].active == true, \"Given Event ID is invalid\");\n    require(events[_eventId].ended == false, \"The event is ended\");\n    require(\n      events[_eventId].claimed[msg.sender] == false,\n      \"The caller is already claimed\"\n    );\n    require(\n      _checkClaim(_eventId, _poapId, _proof) == true,\n      \"The caller is not eligible to claim the given poap\"\n    );\n\n    if (poaps[_poapId].is1155) {\n      IERC1155Upgradeable(poaps[_poapId].assetAddress).safeTransferFrom(\n        address(this),\n        msg.sender,\n        poaps[_poapId].tokenId,\n        1,\n        \"0x00\"\n      );\n    } else {\n      IERC721Upgradeable(poaps[_poapId].assetAddress).safeTransferFrom(\n        address(this),\n        msg.sender,\n        poaps[_poapId].tokenId\n      );\n    }\n\n    events[_eventId].claimed[msg.sender] = true;\n    events[_eventId].claimCount += 1;\n\n    emit Claimed(\n      msg.sender,\n      _eventId,\n      poaps[_poapId].assetAddress,\n      poaps[_poapId].tokenId,\n      poaps[_poapId].is1155\n    );\n  }\n\n  /// @notice deposit ERC-1155 NFT prior to the claim, ideally should be called by the event's owner\n  /// @param _assetAddress the NFT asset address\n  /// @param _tokenId the token ID on the NFT\n  /// @param _amount the amount of NFT to be deposited\n  function depositERC1155(\n    address _assetAddress,\n    uint256 _tokenId,\n    uint256 _amount\n  ) public nonReentrant {\n    IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n      msg.sender,\n      address(this),\n      _tokenId,\n      _amount,\n      \"0x00\"\n    );\n\n    emit Deposited(msg.sender, _assetAddress, _tokenId, _amount, true);\n  }\n\n  /// @notice deposit ERC-721 NFT prior to the claim, ideally should be called by the event's owner\n  /// @param _assetAddress the NFT asset address\n  /// @param _tokenId the token ID on the NFT\n  function depositERC721(address _assetAddress, uint256 _tokenId)\n    public\n    nonReentrant\n  {\n    IERC721Upgradeable(_assetAddress).safeTransferFrom(\n      msg.sender,\n      address(this),\n      _tokenId\n    );\n\n    emit Deposited(msg.sender, _assetAddress, _tokenId, 1, false);\n  }\n\n  /// @notice create a record for POAP NFT which will be used during a claim period for mapping POAP ID <-> ASSET ADDRESS\n  /// @param _poapId ID for the POAP\n  /// @param _assetAddress the NFT asset address\n  /// @param _tokenId the token ID on the NFT\n  /// @param _is1155 ERC-1155 flags\n  function createPoap(\n    uint256 _poapId,\n    address _assetAddress,\n    uint256 _tokenId,\n    bool _is1155\n  ) public nonReentrant onlyWhitelisted {\n    require(poaps[_poapId].assetAddress == address(0), \"Given ID is occupied\");\n\n    poaps[_poapId].assetAddress = _assetAddress;\n    poaps[_poapId].tokenId = _tokenId;\n    poaps[_poapId].is1155 = _is1155;\n\n    emit PoapCreated(_poapId, _assetAddress, _tokenId, _is1155);\n  }\n\n  /// @notice create a campaign\n  /// @param _eventId ID for the event\n  /// @param _name name of the event\n  /// @param _poaps NFT that will be distributed\n  function createEvent(\n    uint256 _eventId,\n    string memory _name,\n    uint256[] memory _poaps\n  ) public nonReentrant onlyWhitelisted {\n    require(events[_eventId].active == false, \"Given ID is occupied\");\n\n    events[_eventId].active = true;\n    events[_eventId].name = _name;\n    events[_eventId].poaps = _poaps;\n\n    emit EventCreated(_eventId, _name, _poaps);\n  }\n\n  /// @notice create a project, once set it allows users to verify that they  having the project's NFTs in the wallet\n  /// @param _projectId ID for the project\n  /// @param _name name of the project\n  function createProject(uint256 _projectId, string memory _name)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    require(projects[_projectId].active == false, \"Given ID is occupied\");\n\n    projects[_projectId].active = true;\n    projects[_projectId].name = _name;\n\n    emit ProjectCreated(_projectId, _name);\n  }\n\n  /// @notice upload the root of the proof identifies who will be able to claim the prizes\n  /// @param _eventId ID for the event\n  /// @param _merkleRoot the root of the proof to be uploaded\n  function attachClaim(uint256 _eventId, bytes32 _merkleRoot)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    require(events[_eventId].active == true, \"Given ID is invalid\");\n\n    events[_eventId].merkleRoot = _merkleRoot;\n  }\n\n  /// @notice upload the root of the proof identifies who is holding the project's NFTs\n  /// @param _projectId ID for the project\n  /// @param _merkleRoot the root of the proof to be uploaded\n  function attachWhitelist(uint256 _projectId, bytes32 _merkleRoot)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    require(projects[_projectId].active == true, \"Given ID is invalid\");\n\n    projects[_projectId].merkleRoot = _merkleRoot;\n    projects[_projectId].timestamp = now;\n  }\n\n  /// @notice upload the root of the proof identifies who is holding the project's NFTs (in batch)\n  /// @param _projectIds array of ID for the project\n  /// @param _merkleRoots array of the root of the proof to be uploaded\n  function attachWhitelistBatch(\n    uint256[] memory _projectIds,\n    bytes32[] memory _merkleRoots\n  ) public nonReentrant onlyWhitelisted {\n    require(\n      _projectIds.length == _merkleRoots.length,\n      \"Array size is not the same length\"\n    );\n\n    for (uint256 i = 0; i < _projectIds.length; i++) {\n      projects[_projectIds[i]].merkleRoot = _merkleRoots[i];\n      projects[_projectIds[i]].timestamp = now;\n    }\n  }\n\n  /// @notice replace POAP NFTs to be distributed on the event\n  /// @param _eventId ID of the event\n  /// @param _poaps array of the POAP ID\n  function updatePoaps(uint256 _eventId, uint256[] memory _poaps)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    require(events[_eventId].active == true, \"Given ID is invalid\");\n\n    events[_eventId].poaps = _poaps;\n  }\n\n  /// @notice withdraw ERC-1155 NFTs locked in the contract\n  function emergencyWithdrawERC1155(\n    address _to,\n    address _tokenAddress,\n    uint256 _tokenId,\n    uint256 _amount\n  ) public nonReentrant onlyWhitelisted {\n    IERC1155Upgradeable(_tokenAddress).safeTransferFrom(\n      address(this),\n      _to,\n      _tokenId,\n      _amount,\n      \"0x00\"\n    );\n  }\n\n  /// @notice withdraw ERC-721 NFTs locked in the contract\n  function emergencyWithdrawERC721(\n    address _to,\n    address _tokenAddress,\n    uint256 _tokenId\n  ) public nonReentrant onlyWhitelisted {\n    IERC721Upgradeable(_tokenAddress).safeTransferFrom(\n      address(this),\n      _to,\n      _tokenId\n    );\n  }\n\n  // @notice withdraw ERC-20 locked in the contract\n  function emergencyWithdrawERC20(address _tokenAddress, uint256 _amount)\n    public\n    nonReentrant\n    onlyWhitelisted\n  {\n    IERC20Upgradeable(_tokenAddress).transfer(msg.sender, _amount);\n  }\n\n  /// @notice finalize event for get seed\n  /// @param _eventId ID of the event\n  function finalizeEvent(uint256 _eventId) public nonReentrant {\n    require(events[_eventId].active == true, \"Given ID is invalid\");\n    require(\n      IERC20Upgradeable(LINK_TOKEN).balanceOf(address(this)) >= FEE,\n      \"Insufficient LINK to proceed VRF\"\n    );\n\n    bytes32 requestId = requestRandomness(KEY_HASH, FEE);\n    requestIdToAddress[requestId] = msg.sender;\n    requestIdToEventId[requestId] = _eventId;\n\n    emit FinalizeEvent(msg.sender, requestId, now);\n  }\n\n  // PRIVATE FUNCTIONS\n\n  function _checkClaim(\n    uint256 _eventId,\n    uint256 _poapId,\n    bytes32[] memory _proof\n  ) internal view returns (bool) {\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _poapId));\n    return\n      MerkleProofUpgradeable.verify(_proof, events[_eventId].merkleRoot, leaf);\n  }\n\n  function _eligible(\n    uint256 _projectId,\n    address _address,\n    bytes32[] memory _proof\n  ) internal view returns (bool) {\n    require(projects[_projectId].active == true, \"Given ID is invalid\");\n\n    bytes32 leaf = keccak256(abi.encodePacked(_address));\n\n    return\n      MerkleProofUpgradeable.verify(\n        _proof,\n        projects[_projectId].merkleRoot,\n        leaf\n      );\n  }\n\n  // callback from Chainlink VRF\n  function fulfillRandomness(bytes32 requestId, uint256 _randomness)\n    internal\n    override\n  {\n    uint256 eventId = requestIdToEventId[requestId];\n\n    if (eventId != 0) {\n      events[eventId].seed = _randomness;\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/cryptography/MerkleProofUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProofUpgradeable {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/vrf/VRFConsumerBaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBaseUpgradeable is Initializable, VRFRequestIDBase {\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(\n    bytes32 requestId,\n    uint256 randomness\n  )\n    internal\n    virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(\n    bytes32 _keyHash,\n    uint256 _fee\n  )\n    internal\n    returns (\n      bytes32 requestId\n    )\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface /*immutable*/ internal LINK;\n  address /*immutable*/ private vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  // constructor(\n  //   address _vrfCoordinator,\n  //   address _link\n  // ) {\n  function initialize(\n    address _vrfCoordinator,\n    address _link\n  ) internal initializer {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(\n    bytes32 requestId,\n    uint256 randomness\n  )\n    external\n  {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}"
    },
    "contracts/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "contracts/vrf/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract VRFRequestIDBase {\n\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n    address _requester, uint256 _nonce)\n    internal pure returns (uint256)\n  {\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "contracts/NFTBroker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract NFTBroker is\n\tOwnableUpgradeable,\n\tReentrancyGuardUpgradeable,\n\tERC1155HolderUpgradeable\n{\n\tstruct NFT {\n\t\taddress assetAddress;\n\t\tuint256[] tokenIds;\n\t}\n\n\tNFT[] private nfts;\n\n\t//address -> fromId -> toId -> Rate\n\tmapping(address => mapping(uint256 => mapping(uint256 => uint8)))\n\t\tprivate rates;\n\n\tevent Deposit(\n\t\taddress indexed depositor,\n\t\taddress nftAddress,\n\t\tuint256 tokenId,\n\t\tuint256 amount\n\t);\n\n\tevent Withdraw(\n\t\taddress indexed withdrawer,\n\t\taddress nftAddress,\n\t\tuint256 tokenId,\n\t\tuint256 amount\n\t);\n\n\tevent SetRate(address nftAddress, uint256 fromId, uint256 toId, uint8 rate);\n\n\tevent RemoveRate(address nftAddress, uint256 fromId, uint256 toId);\n\n\tevent Swap(\n\t\taddress indexed _swapper,\n\t\taddress _nftAddress,\n\t\tuint256 _fromId,\n\t\tuint256 _toId,\n\t\tuint256 _amount\n\t);\n\n\tfunction initialize() external initializer {\n\t\tOwnableUpgradeable.__Ownable_init();\n\t\tReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n\t\tERC1155HolderUpgradeable.__ERC1155Holder_init();\n\t}\n\n\tfunction getNft(uint256 i) public view returns (NFT memory) {\n\t\treturn nfts[i];\n\t}\n\n\tfunction swap(\n\t\taddress _nftAddress,\n\t\tuint256 _fromId,\n\t\tuint256 _toId,\n\t\tuint256 _amount\n\t) public nonReentrant {\n\t\trequire(_nftAddress != address(0), \"Cannot be address 0\");\n\n\t\tuint8 swapRate = getRate(_nftAddress, _fromId, _toId);\n\t\trequire(swapRate != 0, \"Cannot swap because swap rate is 0\");\n\n\t\t//get nft\n\t\tIERC1155Upgradeable(_nftAddress).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\t_fromId,\n\t\t\t_amount,\n\t\t\t\"0x00\"\n\t\t);\n\n\t\t//send nft to nft-sender\n\t\tIERC1155Upgradeable(_nftAddress).safeTransferFrom(\n\t\t\taddress(this),\n\t\t\tmsg.sender,\n\t\t\t_toId,\n\t\t\t(swapRate * _amount),\n\t\t\t\"0x00\"\n\t\t);\n\n\t\temit Swap(msg.sender, _nftAddress, _fromId, _toId, _amount);\n\t}\n\n\tfunction deposit(\n\t\taddress _nftAddress,\n\t\tuint256 _amount,\n\t\tuint256 _tokenId\n\t) public onlyOwner nonReentrant {\n\t\trequire(_amount > 0, \"Amount cannot be zero\");\n\n\t\tIERC1155Upgradeable(_nftAddress).safeTransferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\t_tokenId,\n\t\t\t_amount,\n\t\t\t\"0x00\"\n\t\t);\n\n\t\t_addNft(_nftAddress, _tokenId);\n\n\t\temit Deposit(msg.sender, _nftAddress, _tokenId, _amount);\n\t}\n\n\tfunction withdraw(\n\t\taddress _nftAddress,\n\t\tuint256 _amount,\n\t\tuint256 _tokenId\n\t) public onlyOwner nonReentrant {\n\t\trequire(_amount > 0, \"Amount cannot be zero\");\n\n\t\tIERC1155Upgradeable(_nftAddress).safeTransferFrom(\n\t\t\taddress(this),\n\t\t\tmsg.sender,\n\t\t\t_tokenId,\n\t\t\t_amount,\n\t\t\t\"0x00\"\n\t\t);\n\n\t\temit Withdraw(msg.sender, _nftAddress, _tokenId, _amount);\n\t}\n\n\tfunction setRate(\n\t\taddress _nftAddress,\n\t\tuint256 _fromId,\n\t\tuint256 _toId,\n\t\tuint8 _rate\n\t) public onlyOwner nonReentrant {\n\t\trequire(_nftAddress != address(0), \"Cannot be address 0\");\n\t\trequire(_rate > 0, \"Rate cannot be less than 0\");\n\t\trequire(_fromId != _toId, \"Token id cannot be the same\");\n\n\t\trates[_nftAddress][_fromId][_toId] = _rate;\n\n\t\temit SetRate(_nftAddress, _fromId, _toId, _rate);\n\t}\n\n\tfunction removeRate(\n\t\taddress _nftAddress,\n\t\tuint256 _fromId,\n\t\tuint256 _toId\n\t) public onlyOwner nonReentrant {\n\t\trequire(_nftAddress != address(0), \"Cannot be address 0\");\n\n\t\trates[_nftAddress][_fromId][_toId] = 0;\n\n\t\temit RemoveRate(_nftAddress, _fromId, _toId);\n\t}\n\n\tfunction getRate(\n\t\taddress _nftAddress,\n\t\tuint256 _fromId,\n\t\tuint256 _toId\n\t) public view returns (uint8) {\n\t\treturn rates[_nftAddress][_fromId][_toId];\n\t}\n\n\tfunction _addNft(address _assetAddress, uint256 _tokenId) private {\n\t\tuint256[] memory tokenArr;\n\n\t\tif (nfts.length == 0) {\n\t\t\tnfts.push(NFT({ assetAddress: _assetAddress, tokenIds: tokenArr }));\n\t\t}\n\n\t\tfor (uint256 i = 0; i < nfts.length; i++) {\n\t\t\tNFT storage nft = nfts[i];\n\t\t\tif (nfts[i].assetAddress == _assetAddress) {\n\t\t\t\tnft.tokenIds.push(_tokenId);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttokenArr[0] = _tokenId;\n\t\t\t\tnfts.push(NFT({ assetAddress: _assetAddress, tokenIds: tokenArr }));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n\n    uint256 constant private MAX_SUPPLY =  10000000 * (10 ** 18);\n\n    constructor(\n        string memory name,\n        string memory symbol\n    ) public ERC20(name, symbol) {\n        _mint(msg.sender, MAX_SUPPLY);\n    }\n\n    function faucet() public {\n        _mint(msg.sender, 10000 * (10 ** 18));\n    }\n\n    function deposit(uint256 _amount) public payable {\n        \n    }   \n\n    function withdraw(uint256 _amount) public {\n\n    }\n\n}\n"
    },
    "contracts/mocks/MockLP.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./MockERC20.sol\";\n\ncontract MockLP is MockERC20 {\n\n    address public token0;\n    address public token1;\n\n    constructor(\n        string memory name,\n        string memory symbol\n    ) public MockERC20(name, symbol) {\n       \n    }\n\n}\n"
    },
    "contracts/mocks/MockERC1155.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract MockERC1155 is ERC1155 {\n    constructor(string memory uri) public ERC1155(uri) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function setURI(string memory newuri) public {\n        _setURI(newuri);\n    }\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public {\n        _mint(to, id, value, data);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public {\n        _mintBatch(to, ids, values, data);\n    }\n\n    function burn(\n        address owner,\n        uint256 id,\n        uint256 value\n    ) public {\n        _burn(owner, id, value);\n    }\n\n    function burnBatch(\n        address owner,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public {\n        _burnBatch(owner, ids, values);\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}